










-----> AGORA QUE APRENDEMOS SOBRE COMO 


'SAVE FILES'





E 

SOBRE COMO 


__RETORNAR__ 


ESSAS FILES 

DE DIFERENTES MANEIRAS NO NOSSO APP (




    vimos como AS RETORNAR DE FORMA ESTÁTICA,






E COMO 


__RETORNAR 



'AS A BIG FILE' (preload de data, não é muito bom...),








E COMO 

RETORNAR 


'AS A STREAMED RESPONSE' (MANEIRA ÓPTIMA DE RETORNAR FILES/fazer o user baixar arquivos 

de 

nosso site...)

)












------->  AGORA, NO CASO, 

O PROFESSOR QUER NOS MOSTRAR UM PEQUENO 'BÔNUS',






A MANEIRA 


DE 


_______CRIAR__ UM PDF 'ON THE FLY'



NO NOSSO 

SERVER...









--------> EM VEZ DE 



SERVIR AQUELE 

'HARDCODED PDF',




aquele arquivo 


''fatura-61966d050dd562509c7febe7'''







QUE JÁ 




SERVIMOS VÁRIAS VEZES, PARA 1 MESMO PRODUCT,









__ AGORA __ 





O PROFESSOR VAI QUERER 


'CREATE THAT PDF ON THE FLY'...









----> PARA ISSO, 

__ ELE __ APAGA__ ESSE 


INVOICE/FATURA... (eu mantenho esse arquivo, só para referência...)










----> AÍ ELE VAI 

ATÉ 'shop.js',



NOS CONTROLLERS,



CONTROLLER DE 

'getFatura'...







ex:






exports.getFatura = (req, res, next) => {
  const orderId = req.params.orderId;
  const invoiceName = 'fatura-' + orderId + '.pdf';
  const invoicePath = `${pdfPath}/${invoiceName}`;
  console.log(invoiceName);

  Order.findById(ObjectId(orderId)).then((order) => {
    if (!order) {
      req.flash('error', 'Your order could not be found.')
      return res.redirect('/orders');
    } else {
      if (order.user.userId.toString() !== req.user._id.toString()) {
        req.flash('error', 'Your user was not responsible for that order.');
        return res.redirect('/orders');
      } else {


              //// USE ESTE APPROACH DE 'SERVE' DE DATA... (é o approach de STREAMING OF DATA, e naõ de 'PRELOAD OF DATA'...) --> o stream de data é BEM MELHOR DO QUE O PRELOAD DE DATA, e deve ser utilizado quando tivermos que servir ARQUIVOS _ MAIORES_ aos nossos users... (ver aula 325)....
          const file = fs.createReadStream(invoicePath); ////1
          res.setHeader('Content-Type', 'application/pdf'); ///2
          res.setHeader( ////2 
            'Content-Disposition',
            `inline; filename="${invoiceName}"` 
          )
          file.pipe(res); ////3  ///usado em conjunto com 'file', que é a constante que segura nosso READ STREAM que foi criado por meio de '.createReadStream(localDoArquivo)'... ///file.pipe() é o negócio que VAI STREAMAR A 'CREATED DATA STREAM' PARA DENTRO DO OBJETO 'response' de nosso app... (objeto response é, BTW, uma 'WRITABLE STRING', e é exatamente POR CONTA DISSO QUE PODEMOS ESCREVER 'file.pipe(res)', podemos USÁ-LO COMO PARÂMETRO, para que os conteúdos da readable stream de 'file' consigams ser PIPEADAS a esse objeto-stream......)
      }
    }
  });
};





------------------------------------









---> NESSE CÓDIGO AÍ,




QUANDO 



NÓS CONSEGUIRMOS UM 'INVOICE FOR AN ORDER',





NÃO VAMOS QUERER __ FAZER__ SERVE__ DE UM 


ARQUIVO/FATURA QUE 

JÁ EXISTE,





E SIM 


_____vAMOS QUERER ___ GERAR ESSA FATURA/ARQUIVO ___ 




A PARTIR__ 



DA 

'ORDER DATA DE VERDADE'... (




    ou seja, um AUTO-GENERATE DE NOSSA FATURA...
)













--> ok, mas COMO PODEMOS FAZER ISSO?








--> BEM, PRIMEIRAMENTE CABE DESTACAR QUE VAMOS MANTER AQUELE CÓDIGO QUE 

CHECA 

__ SE 


NÓS REALMENTE __ TEMOS 1 ORDER 

COM ESSE 

'orderId'...





ex:








exports.getFatura = (req, res, next) => {
  const orderId = req.params.orderId;
  const invoiceName = 'fatura-' + orderId + '.pdf';
  const invoicePath = `${pdfPath}/${invoiceName}`;
  console.log(invoiceName);

  Order.findById(ObjectId(orderId)).then((order) => {
    if (!order) {
      req.flash('error', 'Your order could not be found.')
      return res.redirect('/orders');
    } else {
      if (order.user.userId.toString() !== req.user._id.toString()) {
        req.flash('error', 'Your user was not responsible for that order.');
        return res.redirect('/orders');
      } else {







----------------------------------






OK... VAMOS CHECAR SE ESSA ORDER EXISTE, E SE O USER TEM PERMISSÃO PARA A ACESSAR..







---> MAS É CLARO QUE 

ALGUMAS COISAS AÍ __ VÃO MUDAR, NÃO VÃO FICAR ASSIM...









--> NÃO VAMOS MAIS FAZER 'READ' DA FILE, NÃO VAMOS 


LER ESSA FILE 

PARA 




A 



'STREAMAR',

e SIM ___ VAMOS ___ 






CRIAR __ ESSA FILE __ DO 0... (vamos criar a fatura/pdf do zero...)









--> OK, MAS __ COMO PODEMOS __ CRIAR UM PDF?







-----> BEM, EXISTEM TPPS QUE 

PODEMOS USAR....
 


 TPPS QUE DEIXAM NOSSA VIDA BEM MAIS FÁCIL... 










 ---> O PACKAGE QUE VAMOS USAR É 

 O 

 'PDFKit'.. 







 É UM PACKAGE USADO 








 __ NA CRIAÇAÕ DE PDFS 



 EM SERVIDORES NODEJS...












 ------> É SUPER FORTE, FAZ UM MONTE DE COISAS...








 --> VAMOS CRIAR UM PDF BEM SIMPLES, nesse curso...










 -----> BEM, PARA A DOCUMENTAÇÃO,





 É IMPORTANTE SABER QUE OS DOCS USAM 'COFFEESCRIPT'...










 É COMO UM 'SUPERSET' ao javascript... --> não é suportaod pelo node,


 É 

 APENAS 
 UMA 

 FERRAMENTA 



 PARA ESCREVER 



 SEU CÓDIGO... (
     pq 

     é 

     compilada 

     de volta a javascript...
 )








 --> É POR ISSO QUE OS DOCS PODEM SER UM POUCO DIFÍCEIS DE LER...










 ---------> MAS O PROFESSOR NOS MOSTRA COMO 


 USAR ESSE PACKAGE NESSE MÓDULO...










 ELE EXECUTA 


 'npm install --save pdfkit'...







 ------------------------


 SALVAMOS TUDO E REINICIAMOS NOSSO SERVER..










 --> 


PARA USAR 

O 

PDFKIT,


PROFESSOR 

VAI ATÉ 
O CONTROLLER 




de 

'shop.js'



E IMPORTA 



ESA PACKAGE...





ESCREVE 

'const pdfkit = require('pdfkit');











--------------------------------





--------> BEM... na verdade essa package expõe um 




'PDF DOCUMENT CONSTRUCTOR',



um constructor de 'pdf document',


E POR ISSO 

o 

professor 


RENOMEIA 


essa const 

como 


'const PDFDocument = require('pdfkit');'








FICA TIPO ASSIM:










// const products = [];

const Product = require('../models/product');

const fs = require('fs'); ///vamos precisar disso para RETORNAR O PDF DAS FATURAS DINÂMICAS...

// const Cart = require('../models/cart'); //NÃO PRECISAMOS DO CART MODEL DIRETAMENTE, POR MEIO DESSE IMPORT AÍ, PQ NÓS O OBTIVEMOS POR MEIO DE 'req.user.getCart()' (magic method criado em 'user', quando executamos 'Cart.belongsTo(User)'...)
// const OrderItem = require('../models/order-item');
// const Order = require('../models/order'); ///assim como um CART É RELACIONADO A UM 'USER', uma 'ORDER' também o é.... --> é por isso que podemos executar o método mágico 'req.user.createOrder'...
// const CartItem = require('../models/cart-item-deprecado-sql');


const PDFDocument = require('pdfkit'); ///esse package importa um CONSTRUCTOR de 'PDFDocument'...



const ObjectId = require('mongodb').ObjectId;

const Order = require('../models/order');
const User = require('../models/user');

const { validationResult } = require('express-validator');

const path = require('path');

const pdfPath = path.join(__dirname, '..', 'faturas');
console.log(pdfPath);

// exports.getAddProductPage = (req, res, next) => {
//   res.render('admin/add-product', {
//     pageTitle: 'Add Product', //RENDER. USADO COM TEMPLATING ENGINES COMO 'pug'...
//     path: '/admin/add-product',
//     activeAddProduct: true,
//     productCSS: true,
//     formsCSS: true,
//   });
// };

// exports.getProductDetailPage = (req, res, next) => {
//     res.render('product-detail', {

//     })

// }

exports.getStartingPage = (req, res, next) => {
  // const isLoggedIn = req.get('Cookie').trim().split('=')[1];
  res.render('shop/index', {
    path: '/',
    pageTitle: 'The Shop',
    // isLoggedIn: req.session.isLoggedIn, ///funcional, mas também CUMBERSOME, como esse código logo abaixo... --> os dois foram substituídos pelo approach de 'res.locals' (feature do EXPRESSJS) LÁ NO APP.JS....
    // csrfToken: req.csrfToken() ///approach CUMBERSOME de adicionar uma 'CSRF TOKEN' (que é importante) À EXECUÇÕES DE ROUTES EM NOSSO APP (no nosso exemplo, controller/route de 'LOGOUT', que é uma feature que SE UTILIZA DE 'post' requests...)
    // isLoggedIn: 'xx'
    // isLoggedIn: isLoggedIn
  });
};

exports.getCheckoutPage = (req, res, next) => {
  res.render(
    'shop/checkout'
    // {
    //   pageTitle: 'checkout',
    //   path: '/shop/checkout'
    // }
  );
};

// exports.postAddProduct = (req, res, next) => {
//   // products.push({ title: req.body.title });

//   const newProduct = new Product(req.body.title);
//   newProduct.save();  //é código assíncrono, no final das contas...
//   res.status(302).redirect('/');
// };

// exports.getProducts = (req, res, next) => {
//   // const products = adminData.products; ////código obsoleto, só fazia sentido em 'shop.js', arquivo route...

//   const products =  Product.fetchAll();

//   // console.log(products, 'LINE');

//   // console.log(products, 'LINE');
//    res.render('shop', {
//     prods: products,
//     pageTitle: 'Shop',
//     path: '/',
//     productCSS: true,
//     activeShop: true,
//     hasProducts: products.length > 0,
//   });
// };

// exports.getCartPage = (req, res, next) => { ////MINHA VERSÃO DO CÓDIGO. NÃO FUNCIONAVA.

//  Cart.getCartFromFile(

//     (cart) => { //callback....
//           console.log('A');
//           const cartProducts = [];
//         for (const product of cart.products) {
//             Product.findProduct(product.id,

//               (product) => { ///callback
//                   cartProducts.push(product);
//                   console.log('B');
//                   console.log(cartProducts);
//               }
//               )
//         }

//         console.log('C');
//         res.render('shop/cart', {
//           path: '/cart',
//           pageTitle: 'Cart',
//           cartProducts: cartProducts
//         });
//     }
//   )

// };

exports.getCart = (req, res, next) => {
  //  req.user.getCart() MÉTODO MONGODB DRIVER COMUM...

  ///'req.user' realmente é o código correto PARA __ CHAMAR_ OS 'METHODS MONGOOSE' aqui, e __ NAÕ 'req.ses
  // req.user ///CÓDIGOS/métodos BUILTIN do mongoose.... vamos querer eles, vamos querer o MELHOR DOS 2 MUNDOS (as SESSIONS para identificar nossos users/dividir a data __ E ___ TAMBÉM__ O objeto/model 'user' COM TODOS OS METHODS DO MONGODB __ dentro desse objeto 'user' no nosso request... é exatamenete por isso que estamos usando 'req.user' neste local...)

  //req.session.user //NÃO USE ESTE CÓDIGO (pq se você usar, estará __ TENTANDO CHAMAR '.populate()' EM 1 OBJETO __ QUE __ NÃO TEM/NÃO TERÁ ___ OS METHODS MÁGICOS DO MONGOOSE, justamente pq __ SE TRATA APENAS DE 1 SIMPLES 'SESSION' com alguam data chata de 'user' ARMAZENADA NO SEU MEIO, o que signfiica que __ NAÕ TERÁ/NÃO TEM OS __ METHODS MONGOOSE DE QUE TANTO PRECISAMOS, dentro de si...)
  req.user
    .populate('cart.products.productId') //////EIS O CÓDIGO EM QUESTÃO
    ///.execPopulate() ///OPCIONAL. antes era obrigatório, vocÊ tinha que chamar isso para poder EXECUTAR then/catch em cima do 'populate' (pq antigamente o POPULATE NÃO RETORNAVA SEMPRE UMA PROMISE, como hoje em dia...)
    .then((user) => {
      ///////RESTO DO CÓDIGO CONTINUA O MESMO....

      // const isLoggedIn = req.get('Cookie').trim().split('=')[1];
      console.log(user.cart.products, 'CARTPRODUCTS');

      res.render('shop/cart', {
        path: '/cart',
        pageTitle: 'Your Cart',
        products: user.cart.products,
        // isLoggedIn: req.session.isLoggedIn
        // isLoggedIn: isLoggedIn
      });
    })
    .catch((err) => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });

  ///É MEU CÓDIGO DE FETCH CART.... não é tão bonito, mas funciona, e faz a vinculação de 2 'collections' diferentes, pq pega os products 'simples' la dentro do 'cart', dentro de cada 'user', e aí VINCULA ISSO (products que possuem as QUANTITIES, pq são cart items)  COM __ AS INFORMAÇÕES DETALHADAS DE CADA PRODUCT, armazenadas nos objetos/documentos 'product' lá na collection de 'products' mesmo....

  //   const productIds = [];

  //   const simpleProducts = [];

  //   const cart = req.user.getCart(); ///poderíamos conseguir o MESMO EFEITO por meio do call de 'req.user.cart', se quiséssemos... (é a mesma coisa...)

  // const cartProducts = [
  //   ...cart.products
  // ]

  // cartProducts.forEach(
  //   (product) => {
  //       productIds.push(product.productId);
  //       simpleProducts.push(product);
  //   }
  // )

  //   Product.getMultipleProducts(productIds)
  //   .then(
  //     (products) => {

  //         const editedProducts = [];

  //         products.forEach(
  //           (product) => {

  //          const neededProductIndex = simpleProducts.findIndex(
  //               (prod) => {
  //                     console.log(ObjectId(prod.productId) === ObjectId(product._id))
  //                     return prod.productId.toString() === product._id.toString();
  //               }
  //             )

  //               if(neededProductIndex === -1) {

  //                 return;
  //               } else {

  //                 const editedProduct = {
  //                   ...product,
  //                   quantity: simpleProducts[neededProductIndex].quantity
  //                 }

  //                     editedProducts.push(
  //                             editedProduct
  //                     )
  //               }
  //           }
  //         )

  //       res.render('shop/cart', {
  //         path: '/cart',
  //         pageTitle: 'Your Cart',
  //         products: editedProducts

  //     })
  //     }
  //   )

  // .then(
  //   (cart) => {

  //     (cart) => {

  //       console.log(cart);

  //       res.render('shop/cart', {
  //         path: '/cart',
  //         pageTitle: 'Your Cart',
  //         products: products,
  //         cart: cart
  //         // cartItems: cartItems
  //     })
  //     }
  //   }
  // )
  //   .catch(
  //     (err) => {
  //       console.log(err);
  //     }
  //   )

  ///CÓDIGO QUE USA/USAVA SEQUELIZE...
  // console.log(req.user.cart, 'LINE'); ////isso (o cart) não existe dentro do objeto 'req.user', justamente pq DEVEMOS O CONSEGUIR ATRAVÉS DE 'req.user.getCart()', para conseguir o cart específico Àquele user (userId field dentro do cart e 'id' field no user DEVEM DAR MATCH...)

  //   // let productList;
  //  req.user
  //     .getCart()
  //     .then((cart) => {

  //       const fetchedCart = cart;
  //       return cart.getProducts()

  //       .then(products => {
  //           console.log(products);
  //  res.render('shop/cart', {
  //         path: '/cart',
  //         pageTitle: 'Your Cart',
  //         products: products,
  //         cart: fetchedCart
  //         // cartItems: cartItems
  //     })
  //   })
  //     .catch((err) => {
  //       console.log(err);
  //     })

  //   }
  //     )
  //       .catch(
  //         (err) => {console.log(err)}
  //       )

  ///////ESTA ERA A MINHA VERSÃO DO CÓDIGO, VERSÃO QUE NÃO SABIA QUE PODÍAMOS, LÁ NO VIEW, simplesmente acessar a quantity de um 'given ASSOCIATED cart item' por meio de 'product.cartItem.quantity'...
  // let productList;

  // const cartId = req.user
  //   .getCart()
  //   .then((cart) => {
  //     console.log(cart, 'LINE');
  //     return cart.getProducts();
  //   })
  //   .then((products) => {
  //     console.log(products);

  //     productList = products;

  //     CartItem.findAll({ where: { cartId: req.user.id } }).then((cartItems) => {
  //       productList.forEach((product) => {
  //         product.quantity = cartItems.find((cartItem) => {
  //           return cartItem.productId === product.id;
  //         }).quantity;
  //       });
  // return res.render('shop/cart', {
  //   path: '/cart',
  //   pageTitle: 'Your Cart',
  //   cartProducts: productList,
  //   // cartItems: cartItems
  // });
  //     });
  //   })
  //   .catch((err) => {
  //     console.log(err);
  //   });
};

exports.deleteCartItem = (req, res, next) => {
  const productId = req.body.id;

  // console.log('TEST', 'TEST', productId, 'TEST');

  req.user
    .deleteCartItem(productId)
    .then((result) => {
      res.status(302).redirect('/cart');
    })
    .catch((err) => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });

  // const updatedProducts = req.user.cart.products.filter( ///////OUTSOURCEADO LÁ PARA O METHOD de 'deleteCartItem', no model de 'user.js'....
  //   (product) => {
  //             console.log(productId.toString() !== product.productId.toString())
  //             return  productId.toString() !== product.productId.toString();
  //   }
  // )

  // req.user.cart.products = updatedProducts;

  // req.user.save().then(
  //   (result) => {

  //     res.redirect('/cart');
  //   }
  // )

  // req.user.deleteProductFromCart(productId) // código sem o mongoose...
  // .then(
  //   (result) => {

  //     res.redirect('/cart');
  //   }
  // )
  // .catch(
  //   (err) => {
  //     console.log(err);
  //   }
  // )

  // const user = req.user;

  /////////CÓDIGO __SEM O MONGOOSE__... (só com o mongodb driver default... e seus models default, com  methods inventados por nós...)
  // req.user.deleteProductFromCart(productId)
  // .then(
  //   (result) => {
  //     res.redirect('/cart');
  //   }
  // )
  // .catch(
  //   (err) => {
  //     console.log(err);
  //   }
  // )

  // req.user.deleteProductFromCart(productId)
  // .then(
  //   (result) => {

  //     res.redirect('/cart');
  //   }
  // )
  // .catch(
  //   (err) => {
  //     console.log(err);
  //   }
  // )

  ///CÓDIGO QUE USA/USAVA SEQUELIZE...
  // const productId = req.body.id;
  // // const productPrice = req.body.price; ////esta versão do código __ NÃO FUNCIONA___ (pq é o price _ GERAL__ que vai ser considerado, nesse negócio, e não o PRICE DE CADA PRODUCT INDIVIDUAL..)
  // // console.log(productId);

  // // Product.findProduct(productId, (product) => {
  // //   console.log(product, 'LINE');
  // //   Cart.deleteProductFromCart(productId, product.price);
  // //   res.redirect('/cart');
  // // });

  // req.user.getCart().then(
  //   (cart) => {

  //       return cart.getProducts({where: {id: productId}});
  //   }
  // )
  // .then(
  //     (products) => {

  //       const product = products[0];

  //       if (product.cartItem.quantity === 1) {

  //        return product.cartItem.destroy();

  //       } else {

  //         newCartItem = {
  //           ...product.cartItem
  //         }

  //         newCartItem.quantity = product.cartItem.quantity - 1;

  //        return product.cartItem.update(newCartItem);
  //       }
  //     }

  // )
  // .then(
  //   (result) => {
  //         res.redirect('/cart');
  //   }
  // )
};

// exports.getOrdersPage = (req, res, next) => {
//   res.render('shop/orders', {
//     pageTitle: 'Your Orders',
//     path: '/orders',
//   });
// };

exports.getOrdersPage = (req, res, next) => {
  ///'req.user' realmente é o código correto PARA __ CHAMAR_ OS 'METHODS MONGOOSE' aqui, e __ NAÕ 'req.ses
  // req.user ///CÓDIGOS/métodos BUILTIN do mongoose.... vamos querer eles, vamos querer o MELHOR DOS 2 MUNDOS (as SESSIONS para identificar nossos users/dividir a data __ E ___ TAMBÉM__ O objeto/model 'user' COM TODOS OS METHODS DO MONGODB __ dentro desse objeto 'user' no nosso request... é exatamenete por isso que estamos usando 'req.user' neste local...)

  //req.session.user //NÃO USE ESTE CÓDIGO (pq se você usar, estará __ TENTANDO CHAMAR '.populate()' EM 1 OBJETO __ QUE __ NÃO TEM/NÃO TERÁ ___ OS METHODS MÁGICOS DO MONGOOSE, justamente pq __ SE TRATA APENAS DE 1 SIMPLES 'SESSION' com alguam data chata de 'user' ARMAZENADA NO SEU MEIO, o que signfiica que __ NAÕ TERÁ/NÃO TEM OS __ METHODS MONGOOSE DE QUE TANTO PRECISAMOS, dentro de si...)

  let message = req.flash('error');

  if (message.length > 0) {
    message = message[0];
  } else {
    message = null;
  }


  console.log(req.user._id);

  const errors = validationResult(req);

  const validationErrors = errors.array();




  Order.find({ user: { userId: req.user._id } })
    // .populate('cart.products.productId')
    .populate('products.product')
    .then((orders) => {
      console.log(orders, 'THE ORDERS');

      // const isLoggedIn = req.get('Cookie').trim().split('=')[1];

      orders.forEach((order) => {
        console.log(order, 'LINE');

        order.products.forEach((product) => {
          console.log(product, 'LINE2');
        });

        // order.totalPrice = order.cart.products
        order.totalPrice = order.products
          .map(
            ////define o TOTAL PRICE de cada order...
            (product) => {
              console.log(product, 'LINE3');
              // return product.productId.price * product.quantity;
              return product.product.price * product.quantity;
            }
          )
          .reduce((prevValue, curValue) => {
            return prevValue + curValue;
          }, 0);
      });

      res.render('shop/orders', {
        pageTitle: 'Your Orders',
        orders: orders,
        path: '/orders',
        // errorMessage: null,
        errorMessage: message,
        validationErrors: validationErrors
        // isLoggedIn: isLoggedIn
        // isLoggedIn: req.session.isLoggedIn
      });
    })
    .catch((err) => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });

  // req.user.getOrders() //////CÓDIGO SEM O USO DO MONGOOSE/ MONGOOSE METHODS EM MONGOOSE MODELS....
  // .then(
  //   (orders) => {

  //     console.log(orders, 'YOUR ORDERS');

  //     res.render(
  //       'shop/orders',
  //       {
  //         pageTitle: 'Your Orders',
  //         orders: orders,
  //         path: '/orders'
  //       }
  //     )
  //   }
  // )
  // .catch(
  //   (err) => {
  //     console.log(err);
  //   }
  // )

  ///CÓDIGO QUE USA/USAVA SEQUELIZE....

  // req.user.getOrders(

  //     {include: ['products']} //EXEMPLO DE EAGER LOADING... --> vai colocar um field mágico de 'products', com um ARRAY DE PRODUCTS PERTENCENTE 'FOR A GIVEN ORDER' __EM CADA 1 DE NOSSAS ORDERS QUE FOREM RETRIEVADAS por meio desse 'getOrders'...
  // )
  // .then(

  //   (orders) => {

  //     res.render('shop/orders', {
  //       pageTitle: 'Your Orders',
  //       orders: orders,
  //       path: '/orders',
  //     });

  //   }
  // )
  // .catch(
  //   (err) => {
  //     console.log(err);
  //   }
  // )
};

exports.postToCart = (req, res, next) => {
  const productId = req.body.productId;
  // console.log(productId);

  //  return Product.getSingleProduct(ObjectId(productId)) //////CÓDIGO QUE USAVA METHOD definido em model COMUM, model de 'mongodb driver' default, comum, SEM O MONGOOSE....
  //   .then(
  //     (product) => {
  //       console.log(product, 'postToCart')
  //             req.user.addToCart(product)
  //             .then(
  //               (result) => {
  //                       console.log(result);
  //                       res.redirect('/cart');
  //               }
  //             )
  //             .catch(
  //               (err) => {
  //                 console.log(err);
  //               }
  //             )
  //     }
  //   )
  //   .catch(
  //     (err) => {
  //       console.log(err);
  //     }
  //   )

  ////APPROACH QUE UTILIZA O MONGOOSE, BEM MAIS LEGAL E AVANÇADO DO QUE O DE CIMA...

  Product.findById(productId) ///método MONGOOSE... builtin em TODOS NOSSOS MODELS... --> vai automaticamente 'wrappar' o 'productId' em um 'objectId(xxxx)'....
    .then((product) => {
      return req.user.addToCart(product); ////esse método, MÉTODO CUSTOM, criado por NÓS, já contém a lógica que determina se NÓS VAMOS 'CREATE A NEW PRODUCT' (nenhum product com esse '_id' encontrado no 'cart' do 'user'....)  __ OU SE VAMOS SÓ ADICIONAR 1 unidade 'quantity'  no field de 'quantity' de um object QUE JÁ EXISTE (ou seja, já temos 1 product com esse '_id' no array de 'products', dentro do 'cart', dentro de 'user'.....)
    })
    .then((result) => {
      console.log(result);
      res.redirect('/cart');
    })
    .catch((err) => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });

  // //CÓDIGO QUE USA/USAVA SEQUELIZE...
  // const productId = req.body.productId;
  // let fetchedCart;
  // let newQuantity = 1;
  // // const productPrice = req.body.price; //não consigo adquirir essa informação dessa forma...

  // // console.log(productId);

  // // Product.findProduct(
  // //   productId,

  // //   (product) => {
  // //     Cart.addProduct(product.id, product.price);
  // //     res.redirect('/cart');
  // //   }
  // // );

  // req.user
  //   .getCart()
  //   .then((cart) => {
  //     fetchedCart = cart;

  //     return cart.getProducts({ where: { id: productId } }); ////retornamos o valor dessa promise para PODERMOS RODAR CHECKS NELA, NO PRÓXIMO THEN BLOCK...
  //   })
  //   .then((products) => {
  //     //array que precisa ser MANIPULADO, como visto no código de 'product = products[0]'...

  //     let product;

  //     if (products.length > 0) {
  //       product = products[0];
  //     }

  //     if (product) {

  //       const oldQuantity = product.cartItem.quantity;

  //       newQuantity = oldQuantity + 1;

  //       return fetchedCart.addProduct(product, {  ////código parecido com o de baixo, mas com um valor de QUANTITY diferente, valor que considera a EXISTÊNCIA PRÉVIA DE 1 objeto 'product' no nosso cart (reproduzido por 'cart-items'..)
  //         through: {quantity: newQuantity}
  //       })

  //       //////MINHA VERSÃO DESTE CODIGO. É MENOS ELEGANTE, e não usava o field 'quantity' dentro do 'cartItem' vinculado ao 'product'...
  //       // CartItem.findAll({ where: { productId: productId } }) ////como um PRODUCT com aqueles critérios JÁ FOI ENCONTRADO NO NOSSO CART, NÃO VAMOS QUERER CRIAR 1 NOVO 'PRODUCT', E SIM vamos querer adicionar 1 unidade À 'quantity' 'old' de nossos products...
  //       //   .then((cartItems) => {
  //       //     const cartItem = cartItems[0];

  //       //     CartItem.update(
  //       //       { quantity: cartItem.quantity + 1 },
  //       //       { where: { productId: productId } }
  //       //     ) ////CÓDIGO ABSURDAMENTE CLUNKY, MAS QUE FUNCIONOU..
  //       //       .then((result) => {
  //       //         console.log(result);
  //       //       });
  //       //   });
  //     } else {
  //       return Product.findByPk(productId) ///executamos isto pq queremos ADICIONAR ESSE PRODUCT ESPECÍFICO, sua data, ao nosso cart....
  //         .then((product) => {

  //           console.log(fetchedCart, 'O cart em questão'); ///este 'addProduct' aqui de baixo é bem bugado, professor passou 'product' como seu parâmetro, e ele não dá erro, realmente aceita esse parâmetro....
  //           return fetchedCart.addProduct(product, {
  //             through: { quantity: newQuantity },
  //           }); ///ver anotações em 'adicionando novos products ao nosso cart', ou a aula '163' do professor....
  //         })
  //         .catch((err) => {
  //           console.log(err);
  //         });
  //     }

  //     // return Product.findByPk(productId) ///executamos isto pq queremos ADICIONAR ESSE PRODUCT ESPECÍFICO, sua data, ao nosso cart....
  //     // .then(
  //     //   product => {
  //     //     console.log(product, 'O product encontrado no database...');

  //     //     console.log(fetchedCart, 'O cart em questão'); ///este 'addProduct' aqui de baixo é bem bugado, professor passou 'product' como seu parâmetro, e ele não dá erro, realmente aceita esse parâmetro....
  //     //         return fetchedCart.addProduct(product, {through: {quantity: newQuantity}}) ///ver anotações em 'adicionando novos produts ao nosso cart', ou a aula '163' do professor....
  //     //   }
  //     // )
  //   })
  //   .then(() => {
  //     res.redirect('/cart');
  //   })
  //   .catch();
};

exports.getProductDetailPage = (req, res, next) => {
  // const productId = req.params.productId; ////////CÓDIGO QUE __NÃO UTILIZAVA 'sequelize'... --> devemos usar SEQUELIZE, POIS É BEM MAIS PRÁTICO...
  // console.log(productId);

  //   Product.findProduct(productId)
  //   .then(
  //     ([rows, fieldData]) => {
  //           // console.log(rows[0]);
  //       const productData = {
  //         ...rows[0]
  //       }
  //       console.log(productData);
  //           // const productDetail = {...rows[0][0]}
  //           // console.log(productDetail);
  //           // console.log(rows[0].title);
  //               res.render('shop/product-detail', {
  //     pageTitle: productData.title,
  //     path: '/products',
  //     product: productData
  //   });
  //     }
  //   )
  //   .catch(
  //     (err) => {
  //       console.log(err);
  //     }
  //   )

  const productId = req.params.productId.trim();
  // console.log(productId);
  console.log(productId);
  console.log(productId.length);

  if (productId.length < 24) {
    return;
  }

  // Product.getSingleProduct(ObjectId(productId)) ////método ESTÁTICO criado por nós, PARA SER USADO COM O 'MONGO DB DRIVER' comum (sem o mongoose... por isso, pior).... ------> o  método builtin do mongoose, 'findOne()', é melhor do que esse método wonky que escreveoms...
  // Product.findOne({_id: ObjectId(productId)}) ////MÉTODO BUILTIN DO MONGOOSE, EXISTENTE EM TODOS OS MODELS MONGOOSE CRIADOS POR NÓS... ---->  O 'findOne()' É A MESMA COISA QUE 'findById()', com a diferença que ele NÃO VAI AUTOMATICAMENTE CONVERTER o argumento passado por você em 'ObjectId(argumento)'....
  Product.findById(productId) ///Finds a single document by its _id field. findById(id) is almost* equivalent to findOne({ _id: id }). If you want to query by a document's _id, use findById() instead of findOne().

    .then((product) => {
      if (!product) {
        return;
      }

      const isLoggedIn = req.get('Cookie').trim().split('=')[1];
      // console.log(product, 'LINEE');
      res.render('shop/product-detail', {
        pageTitle: product.title,
        path: '/products',
        product: product,
        // isLoggedIn: isLoggedIn
        // isLoggedIn: req.session.isLoggedIn
      });
    })
    .catch((err) => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });

  ////CÓDIGO QUE USA/USAVA SEQUELIZE...
  // const productId = req.params.productId;

  // // Product.findById(productId) //SINTAXE DEPRECADA ('findById' substituído por 'findByPk', find by primary key...)
  // Product.findByPk(productId)
  //   .then((product) => {
  //     if (!product) {
  //       return;
  //     }

  //     res.render('shop/product-detail', {
  //       pageTitle: product.title,
  //       path: '/products',
  //       product: product,
  //     });
  //   })
  //   .catch((err) => {
  //     console.log(err);
  //   });
  // Product.findAll(  ///É UM CÓDIGO QUE UTILIZA SEQUELIZE, MAS QUE É MEIO CLUNKY E RECOMENDADO __ PARA QUANDO VOCÊ QUERER __ ACHAR __ MAIS DE 1 PRODUCT POR MEIO DE UM 'ID'.... --> como aqui só queremos encontrar 1 ÚNICO PRODUCT, VOCÊ DEVE USAR O CÓDIGO LOGO ACIMA, de 'findById'....
  //   {where: {id: productId}} ////use esse código para __ QUERIES__ MAIS AVANÇADOS/ESPECÍFICOS, SELECIONANDO MÚLTIPLOS PRODUTOS COM AQUELE CRITÉRIO QUE VOCÊ PASSA NO SLOT  'CONFIG'...
  // )
  // .then(
  //   (productData) => {
  //       const product = productData[0].dataValues;
  //                     res.render('shop/product-detail', {
  //       pageTitle: product.title,
  //       path: '/products',
  //       product: product
  //     })
  // Product.findProduct(productId, (product) => { /////CÓDIGO QUE USAVA O FILESYSTEM....
  //   // console.log(product, 'LINE2122');
  //   // return product;

  //   if (!product) {
  //     ////conserta o problema de 'product.title' is undefined...
  //     return;
  //   }
  //   res.render('shop/product-detail', {
  //     pageTitle: product.title,
  //     path: '/products',
  //     product: product,
  //   });
  // });
};

// exports.getProductsPage = (req, res, next) => { ///VERSÃO QUE NÃO USAVA O SEQUELIZE. FUNCIONA, MAS É PIOR DE ESCREVER....

//    //é código assíncrono, no final das contas...

//    Product.fetchAll(
//    )
//    .then(
//     ([rows, fieldData]) => { ///'fieldData' --> é a METADATA acerca de nossa data (que é 'rows') retrievada da database SQL...
//       res.render('shop/product-list', {
// prods: rows, ////EIS O CÓDIGO EM QUESTÃO.
// pageTitle: 'Shop',
// path: '/products',
// productCSS: true,
// activeShop: true,
// hasProducts: rows[0].length > 0,
// });
// })
//   // Product.fetchAll((products) => { //minha versão. errada.
//   //

//   //   res.render('shop/product-list', {
//   //     prods: products,
//   //     pageTitle: 'Shop',
//   //     path: '/products',
//   //     productCSS: true,
//   //     activeShop: true,
//   //     hasProducts: products.length > 0,
//   //   });
//   // });
// };

exports.orderPost = (req, res, next) => {
  // console.log(req.user, 'LINE');
  // const user = req.user;

  // const order = new Order( ///MEU CÓDIGO DE 'add a order'.... até funcionou, mas é menos elegante que o código do professor....
  //   {
  //     userId: req.user._id,
  //     cart: req.user.cart,
  //     totalPrice: 0
  //   }
  // )

  // order.save().then(
  //   (result) => {

  //     console.log(result);

  //       return req.user.clearCart()
  //       .then(
  //         (result) => {
  //           res.status(302).redirect('/orders');
  //         }
  //       )
  //   }
  // )

  ///'req.user' realmente é o código correto PARA __ CHAMAR_ OS 'METHODS MONGOOSE' aqui, e __ NAÕ 'req.ses
  // req.user ///CÓDIGOS/métodos BUILTIN do mongoose.... vamos querer eles, vamos querer o MELHOR DOS 2 MUNDOS (as SESSIONS para identificar nossos users/dividir a data __ E ___ TAMBÉM__ O objeto/model 'user' COM TODOS OS METHODS DO MONGODB __ dentro desse objeto 'user' no nosso request... é exatamenete por isso que estamos usando 'req.user' neste local...)

  //req.session.user //NÃO USE ESTE CÓDIGO (pq se você usar, estará __ TENTANDO CHAMAR '.populate()' EM 1 OBJETO __ QUE __ NÃO TEM/NÃO TERÁ ___ OS METHODS MÁGICOS DO MONGOOSE, justamente pq __ SE TRATA APENAS DE 1 SIMPLES 'SESSION' com alguam data chata de 'user' ARMAZENADA NO SEU MEIO, o que signfiica que __ NAÕ TERÁ/NÃO TEM OS __ METHODS MONGOOSE DE QUE TANTO PRECISAMOS, dentro de si...)

  req.user.populate('cart.products.productId').then((user) => {
    const products = user.cart.products.map((product) => {
      return {
        quantity: product.quantity,
        // product: product.productId,
        product: { ...product.productId._doc }, /////// professor explica que VAI USAR  o SPREAD OPERATOR nesse  'product.productId', MAS QUE  NÃO VAI USAR  ISSO  NESSE 'id' aí, e SIM __ EM  __UM __ FIELD ESPECIAL__  QUE O  MONGOOSE NOS DÁ, QUE É  O   FIELD DE  '._doc'..         PROFESSOR NOS EXPLICA QUE PODEMOS CHAMAR '... xxxx._doc' NESSE 'productId' aÍ  _JUSTAMENTE__/APENAS  PQ   O 'productId' _SERÁ ACTUALLY___ UM  OBJETO  COM __ UM MONTE___ DE METADATA  ANEXADA A ELE... ( ainda que  essa metadata seja COMPLETAMENTE INVISÍVEL.... mesmo com console.logs.. ) --> MAS COM '._doc', O QUE  CONSEGUIMOS É O __ ACESSO__  A ___rEALMENTE__  'just the data thats in there'...           ____ OU SEJA___, VAMOS ___ CONSEGUIR __ SÓ A DATA DO 'PRODUCT' VINCULADO a esse  'productId', E NÃO _O 'productId' em si... o que é conveniente... --------> E É CLARO QUE  USAMOS  o  'spread operator' chainado ali  PARA _ 'PULL OUT ALL THE DATA'  desse document que retrievamos, para completar a manipulação de dados e conseguir os encaixar naquela key de 'product'...
      };
    });

    const order = new Order({
      user: {
        name: req.user.name,
        userId: req.user,
      },

      products: products,

      totalPrice: 0,
    });

    order
      .save()
      .then((result) => {
        return req.user.clearCart().then((result) => {
          res.status(302).redirect('/orders');
        });
      })
      .catch((err) => {
        const error = new Error(err);
        error.httpStatusCode = 500;
        return next(error);
      });
  });

  // Order.addOrder(user)
  // .then(
  //   (result) => {

  //     res.status(302).redirect('/orders');
  //   }
  // )
  // .catch(
  //   (err) => {
  //     console.log(err);
  //   }
  // )

  // req.user.addOrder() /////////CÓDIGO SEM O MONGOOSE.... sem mongoose models e seus methods....
  // .then(
  //   (result) => {

  //     console.log(result);
  //     res.redirect('/orders');
  //   }
  // )
  // .catch(
  //   (err) => {

  //     console.log(err);
  //   }
  // )

  //CÓDIGO QUE USAVA/USA SEQUELIZE....
  // let fetchedCart; //padrão bem recorrente.
  // // let productsArray; ////use este approach, junto com 'productsArray = products' e 'fetchedCart.removeProducts(productsArray)', se você NÃO QUISER USAR/NÃO PUDER USAR O 'fetchedCart.setProduct(null)', que é mais elegante e GASTA MENOS LINHAS DE CÓDIGO.

  //   req.user.getCart(
  //   ).then(

  //     (cart) => {
  //       fetchedCart = cart; //padrão bem recorrente.
  //       console.log(cart);
  //      return cart.getProducts(
  //      );
  //     }

  //   )
  //   .then(
  //     (products) => {

  //       console.log(products, 'LINEE');
  //       productsArray = products

  //        req.user.createOrder(  //////método mágico criado com  ''''User.hasMany(Order);''' e   '''Order.belongsTo(User);'''
  //        )
  //         .then(
  //           (order) => {
  //                               ///aqui vemos um uso de MAP para __ EDITAR/ACRESCENTAR_  UM FIELD EXTRA (quantity) aos PRODUCTS que serão convertidos/adicionados como 'orderItem' na table de 'orderItems'...
  //            return order.addProducts(products.map(  ///////// ///EIS O CÓDIGO EM QUESTÃO. quando falamos de 'Products', aqui, falamos que esses 'records' vão ser adicionados LÁ NA TABLE DE 'orderItems', exatamente como visto neste código aqui: '''' Order.belongsToMany(Product, {through: OrderItem});  e  '''' Product.belongsToMany(Order, {through: OrderItem});  '''''''' ------> PQ SÃO ESSAS 2 LINHAS DE CÓDIGO QUE SETTARAM ESSE COMPORTAMENTO E ESSE MAGIC METHOD DE 'addProducts' nesse OBJETO/instance de 'order'... --> como consequência disso, teremos records/linhas 'orderItem' ADICIONADAS À table de 'orderItems', e cada um desses records terá um field 'orderId', VINCULADO ESPECIFICAMENTE A ESSA 'order' que escrevemos em 'order.addProducts()', aqui...
  //              product => {

  //               product.orderItem = { quantity: product.cartItem.quantity} //professor escreve esse 'product.orderItem' PARA __EDITAR__  O VALOR DE CADA propriedade 'mágica' 'orderItem' dentro de cada 1 de nossos product.... --> e ele vai editar isso para COLOCAR O VALOR CORRETO DO FIELD 'quantity' de cada um desses records 'orderItem', justamente por meio do acesso ao valor 'product.cartItem.quantity', específico a esse product...
  //                return product;
  //              }
  //            ));
  //           }
  //         )
  //         .catch(err => {console.log(err)})
  //       }
  //   )
  //   .then(
  //     (result) => {

  //           return fetchedCart.setProducts(null);
  //           // return fetchedCart.removeProducts(productsArray); ///// ESTE APPROACH TBM FUNCIONA, MAS É MENOS ELEGANTE DO QUE O APPROACH DO PROFESSOR... e precisa das linhas lá em cima de 'let productArray;' e 'productArray = products'...
  //     }
  //   )
  //   .then(
  //     (result) => {

  //       res.redirect('/orders');
  //     }
  //   )
  //   .catch(
  //     (err) => {
  //       console.log(err);
  //     }
  //   )
};

exports.getProductsPage = (req, res, next) => {
  // Product.findAll({where:}).then().catch(); /////ali no PRIMEIRO SLOT DE PARÂMETROS, de 'findAll', VOCÊ PODE COLOCAR __OPÇÕEs__ PARA O FETCH.... (definir restrições, como ''''só retrievar os records que tenham/WHERE 'id' igual a xxxx, etc etc...)

  // Product.getProducts()  ////método criado POR NÓS, lá em 'product', método ESTÁTICO....

  Product.find() ////MÉTODO DO MONGOOSE.... --> sintaxes alternativas (que te dão o CURSOR em vez de um array) ---> 'Product.find().cursosr().eachAsync()'       __ E ____ 'Product.find().cursor().next()' -------> ESSAS 2 VERSÕES VAO TE DAR O _CURSOr__ EM VEZ DE UM ARRAY COM TODOS OS DOCUMENTS... (comportamento contrário àquele do 'mongodb driver' comum, portanto...)
    // .select('title price -_id') ////É A MESMA COISA QUE O SEGUNDO PARÂMETRO DE '.populate()', mas atua sobre OS PRODUCTS RETRIEVADOS por meio de '.find()', e não a DATA RETRIEVADA LÁ DO 'RELATED OBJECT' (que é 'user', no caso desse call inferior de '.populate()')....
    .populate('userId', 'name') ///////// O 'POPULATE' (que deve ser chamado após '.find()', opcionalmente) TE DEIXA DIZER AO  'MONGOOSE' QUE  ELE  DEVE  ''''POPULATE A CERTAIN FIELD ___WITH ALL THE __  DETAILED INFORMATION ABOUT  THAT THING (no caso, o 'user'), NOT JUST ITS ID'''''... --> DE FATO, ISSO É ___MUITO, MAS MUITO ÚTIL... (OBS:: O PARâMETRO, no caso 'userId', é o FIELD QUE VOCÊ DESEJA QUE FIQUE PREENCHIDO POR TODA ESSA DETAILED INFORMATION acerca desse document envolvido na relation (no caso, 'user', o user RELACIONADO ao given product) ... ---> JÁ O SEGUNDO PARÂMETRO CUMPRE A MESMA TAREFA DE '.select('fields a serem retrievados de sua database...')'; OU SEJA, NELE VOCÊ PASSA, COMO PARÂMETRO, UMA STRING DIZENDO __QUAIS __ PRODUCTS __ DEVEM SER __RETRIEVADOS DA DATABASE... (é um parâmetro opcional, exatamente como '.select()' o é...)
    .then((products) => {
      console.log(products);

      // const isLoggedIn = req.get('Cookie').trim().split('=')[1];

      res.render('shop/product-list', {
        prods: products,
        pageTitle: 'Shop',
        path: '/products',
        productCSS: true,
        activeShop: true,
        hasProducts: products.length > 0,
        // isLoggedIn: req.session.isLoggedIn
        // isLoggedIn: isLoggedIn
      });
    })
    .catch((err) => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });

  //  res.render('shop/product-list', {
  //     prods: products,
  //     pageTitle: 'Shop',
  //     path: '/products',
  //     productCSS: true,
  //     activeShop: true,
  //     hasProducts: products.length > 0,
  //   });

  //CÓDIGO QUE USAVA SEQUELIZE....
  // Product.findAll()
  //   .then(
  //     //////DENTRO DO 'THEN BLOCK' vamos ter os nossos products, essencialmente...
  //     (products) => {
  //       res.render('shop/product-list', {
  //         prods: products,
  //         pageTitle: 'Shop',
  //         path: '/products',
  //         productCSS: true,
  //         activeShop: true,
  //         hasProducts: products.length > 0,
  //       });
  //     }
  //   )
  //   .catch();
};

// exports.getFatura = (req, res, next) => { ///VERSÃO DO CÓDIGO QUE FAZIA SERVE DE FILES JÁ EXISTENTES (faturas já existentes)...
//   const orderId = req.params.orderId;
//   const invoiceName = 'fatura-' + orderId + '.pdf';
//   const invoicePath = `${pdfPath}/${invoiceName}`;
//   console.log(invoiceName);

//   Order.findById(ObjectId(orderId)).then((order) => {
//     if (!order) {
//         // console.log('ENTER');
//       req.flash('error', 'Your order could not be found.')
//       return res.redirect('/orders');
//     } else {
//       if (order.user.userId.toString() !== req.user._id.toString()) {
//         // console.log(req.user._id, 'LINE5125');
//         // console.log('ENTER2');
//         req.flash('error', 'Your user was not responsible for that order.');
//         return res.redirect('/orders');
//       } else {
// //         return fs.readFile(`${pdfPath}/${invoiceName}`, (err, data) => { ///////CÓDIGO RUIM, CÓDIGO QUE NÃO FAZ O 'STREAM OF DATA'... (ver aula 325....) --> DEVEMOS SEMPRE 'STREAM THE DATA', tudo para: 1) EVITAR O OVERFLOW DA MEMÓRIA TEMPORÁRIA DE NOSSO APP NODE, que será ocupada pelo READ e RETURN desses arquivos.... 2) EVITAR O ___ LONGO __ TEMPO ATÉ RECEBER UMA 'RESPONSE' POR PARTE DO SERVER....
// //           if (err) {
// //             return next(err);
// //           } else {
// //             console.log(data);
// //             res.setHeader('Content-Type', 'application/pdf'); ////EIS O CÓDIGO EM QUESTÃO. Usamos esse código aí para __ ALTERAR O FILENAME do arquivo que o user vai baixar( pegar um filename mais simples) E TAMBÉM ____ PARA __ CONSEGUIR COLOCAR A EXTENSION DE '.pdf' ao nosso arquivo retornado... (se não fizermos isso, ele será BAIXADO COMO UM ARQUIVO SEM EXTENSÃO.. o que é um lixo...)
// //             // res.setHeader('Content-Disposition', 'attachment' );  //////'inline' --> faz com que seja aberto um 'PDF VIEWER' no nosso browser, para visualizar esse arquivo (e dar a opção de o baixar, se o user quiser)... ---> entretanto, os nomes das files vão ficar zoados, vão ficar em um formato tipo ''61966d050dd562509c7febe7''  ------> o contrário de 'inline' é 'attachment', QUE É O VALOR QUE VAI FAZER COM QUE __ NOSSAS FILES SEJAM BAIXADAS DIRETAMENTE, sem abrir esse VISUALIZADOR DE PDF prévio....
// //             res.setHeader('Content-Disposition', `inline; filename="${invoiceName}"` )
// // //inline vs attachment; decida qual é o melhor para seu aplicativo, dependendo do caso concreto (queremos que o user baixe o arquivo sem qualquer conversinha? ou queremos que ele VISUALIZE O ARQUIVO no 'pdf viewer'/mp3 viewer do browser antes de o baixar? se quisermos essa lenga-lenga, devemos escrever 'inline')
// //             return res.send(data); 
// //           }
// //         });

//               //// USE ESTE APPROACH DE 'SERVE' DE DATA... (é o approach de STREAMING OF DATA, e naõ de 'PRELOAD OF DATA'...) --> o stream de data é BEM MELHOR DO QUE O PRELOAD DE DATA, e deve ser utilizado quando tivermos que servir ARQUIVOS _ MAIORES_ aos nossos users... (ver aula 325)....
//           const file = fs.createReadStream(invoicePath); ////1
//           res.setHeader('Content-Type', 'application/pdf'); ///2
//           res.setHeader( ////2 
//             'Content-Disposition',
//             `inline; filename="${invoiceName}"` 
//           )
//           file.pipe(res); ////3  ///usado em conjunto com 'file', que é a constante que segura nosso READ STREAM que foi criado por meio de '.createReadStream(localDoArquivo)'... ///file.pipe() é o negócio que VAI STREAMAR A 'CREATED DATA STREAM' PARA DENTRO DO OBJETO 'response' de nosso app... (objeto response é, BTW, uma 'WRITABLE STRING', e é exatamente POR CONTA DISSO QUE PODEMOS ESCREVER 'file.pipe(res)', podemos USÁ-LO COMO PARÂMETRO, para que os conteúdos da readable stream de 'file' consigams ser PIPEADAS a esse objeto-stream......)
//       }
//     }
//   });
// };










exports.getFatura = (req, res, next) => { /////VERSÃO DO CÓDIGO QUE __ FAZ AUTO-GENERATE DE PDFS para nossas faturas/invoices...
  const orderId = req.params.orderId; //necessário..
  const invoiceName = 'fatura-' + orderId + '.pdf'; 
  const invoicePath = `${pdfPath}/${invoiceName}`;
  console.log(invoiceName);
 
  Order.findById(ObjectId(orderId)).then((order) => {
    if (!order) {
        // console.log('ENTER');
      req.flash('error', 'Your order could not be found.')
      return res.redirect('/orders');
    } else {
      if (order.user.userId.toString() !== req.user._id.toString()) {
        // console.log(req.user._id, 'LINE5125');
        // console.log('ENTER2');
        req.flash('error', 'Your user was not responsible for that order.');
        return res.redirect('/orders');
      } else {
//         return fs.readFile(`${pdfPath}/${invoiceName}`, (err, data) => { ///////CÓDIGO RUIM, CÓDIGO QUE NÃO FAZ O 'STREAM OF DATA'... (ver aula 325....) --> DEVEMOS SEMPRE 'STREAM THE DATA', tudo para: 1) EVITAR O OVERFLOW DA MEMÓRIA TEMPORÁRIA DE NOSSO APP NODE, que será ocupada pelo READ e RETURN desses arquivos.... 2) EVITAR O ___ LONGO __ TEMPO ATÉ RECEBER UMA 'RESPONSE' POR PARTE DO SERVER....
//           if (err) {
//             return next(err);
//           } else {
//             console.log(data);
//             res.setHeader('Content-Type', 'application/pdf'); ////EIS O CÓDIGO EM QUESTÃO. Usamos esse código aí para __ ALTERAR O FILENAME do arquivo que o user vai baixar( pegar um filename mais simples) E TAMBÉM ____ PARA __ CONSEGUIR COLOCAR A EXTENSION DE '.pdf' ao nosso arquivo retornado... (se não fizermos isso, ele será BAIXADO COMO UM ARQUIVO SEM EXTENSÃO.. o que é um lixo...)
//             // res.setHeader('Content-Disposition', 'attachment' );  //////'inline' --> faz com que seja aberto um 'PDF VIEWER' no nosso browser, para visualizar esse arquivo (e dar a opção de o baixar, se o user quiser)... ---> entretanto, os nomes das files vão ficar zoados, vão ficar em um formato tipo ''61966d050dd562509c7febe7''  ------> o contrário de 'inline' é 'attachment', QUE É O VALOR QUE VAI FAZER COM QUE __ NOSSAS FILES SEJAM BAIXADAS DIRETAMENTE, sem abrir esse VISUALIZADOR DE PDF prévio....
//             res.setHeader('Content-Disposition', `inline; filename="${invoiceName}"` )
// //inline vs attachment; decida qual é o melhor para seu aplicativo, dependendo do caso concreto (queremos que o user baixe o arquivo sem qualquer conversinha? ou queremos que ele VISUALIZE O ARQUIVO no 'pdf viewer'/mp3 viewer do browser antes de o baixar? se quisermos essa lenga-lenga, devemos escrever 'inline')
//             return res.send(data); 
//           }
//         });

              //// USE ESTE APPROACH DE 'SERVE' DE DATA... (é o approach de STREAMING OF DATA, e naõ de 'PRELOAD OF DATA'...) --> o stream de data é BEM MELHOR DO QUE O PRELOAD DE DATA, e deve ser utilizado quando tivermos que servir ARQUIVOS _ MAIORES_ aos nossos users... (ver aula 325)....
          const file = fs.createReadStream(invoicePath); ////1
          res.setHeader('Content-Type', 'application/pdf'); ///2
          res.setHeader( ////2 
            'Content-Disposition',
            `inline; filename="${invoiceName}"` 
          )
          file.pipe(res); ////3  ///usado em conjunto com 'file', que é a constante que segura nosso READ STREAM que foi criado por meio de '.createReadStream(localDoArquivo)'... ///file.pipe() é o negócio que VAI STREAMAR A 'CREATED DATA STREAM' PARA DENTRO DO OBJETO 'response' de nosso app... (objeto response é, BTW, uma 'WRITABLE STRING', e é exatamente POR CONTA DISSO QUE PODEMOS ESCREVER 'file.pipe(res)', podemos USÁ-LO COMO PARÂMETRO, para que os conteúdos da readable stream de 'file' consigams ser PIPEADAS a esse objeto-stream......)
      }
    }
  });
};





----------------------------------------



















OK.... 

E VAMOS QUERER __ CRIAR__ UM NOVO 

_DOCUMENTO __ PDF...









--> UM NOVO DOCUMENTO PDF 

QUANDO 


RECEBERMOS UM NOVO 'INVOICE'...







ou seja,


VAMOS QUERER __ CRIAR __ UM DOCUMENTO PDF 


A PARTIR __ 


DE 



NOSSA ORDER DATA...







VAI SER BASICAMENTE NESSE TRECHO AQUI:














exports.getFatura = (req, res, next) => { /////VERSÃO DO CÓDIGO QUE __ FAZ AUTO-GENERATE DE PDFS para nossas faturas/invoices...
  const orderId = req.params.orderId; //necessário..
  const invoiceName = 'fatura-' + orderId + '.pdf'; 
  const invoicePath = `${pdfPath}/${invoiceName}`;


  Order.findById(ObjectId(orderId)).then((order) => {
    if (!order) {
      req.flash('error', 'Your order could not be found.')
      return res.redirect('/orders');
    } else {
      if (order.user.userId.toString() !== req.user._id.toString()) {
        req.flash('error', 'Your user was not responsible for that order.');
        return res.redirect('/orders');
      } else {

                ///////////AQUi.




          const file = fs.createReadStream(invoicePath); ////1
          res.setHeader('Content-Type', 'application/pdf'); ///2
          res.setHeader( ////2 
            'Content-Disposition',
            `inline; filename="${invoiceName}"` 
          )
          file.pipe(res); ////3  ///usado em conjunto com 'file', que é a constante que segura nosso READ STREAM que foi criado por meio de '.createReadStream(localDoArquivo)'... ///file.pipe() é o negócio que VAI STREAMAR A 'CREATED DATA STREAM' PARA DENTRO DO OBJETO 'response' de nosso app... (objeto response é, BTW, uma 'WRITABLE STRING', e é exatamente POR CONTA DISSO QUE PODEMOS ESCREVER 'file.pipe(res)', podemos USÁ-LO COMO PARÂMETRO, para que os conteúdos da readable stream de 'file' consigams ser PIPEADAS a esse objeto-stream......)
      }
    }
  });
};









------------------------------------











PROFESSOR CRIA UMA NOVA CONSTNATE,




de nome 

'pdfDoc'...



ex:







const pdfDoc = ....








-------> DENTRO DESSA CONSTANT,


VAMOS 



USAR/INSTNACIAR 



AQUELE PACOTE RECÉM IMPORTADO,




escrevendo 



'const pdfDoc = new PDFDocument();'








ex:










exports.getFatura = (req, res, next) => { /////VERSÃO DO CÓDIGO QUE __ FAZ AUTO-GENERATE DE PDFS para nossas faturas/invoices...
  const orderId = req.params.orderId; //necessário..
  const invoiceName = 'fatura-' + orderId + '.pdf'; 
  const invoicePath = `${pdfPath}/${invoiceName}`;


  Order.findById(ObjectId(orderId)).then((order) => {
    if (!order) {
      req.flash('error', 'Your order could not be found.')
      return res.redirect('/orders');
    } else {
      if (order.user.userId.toString() !== req.user._id.toString()) {
        req.flash('error', 'Your user was not responsible for that order.');
        return res.redirect('/orders');
      } else {

          const pdfDoc = new PDFDocument(); /////////EIS O CÓDIGO EM QUESTÃO.




          const file = fs.createReadStream(invoicePath); ////1
          res.setHeader('Content-Type', 'application/pdf'); ///2
          res.setHeader( ////2 
            'Content-Disposition',
            `inline; filename="${invoiceName}"` 
          )
          file.pipe(res); ////3  ///usado em conjunto com 'file', que é a constante que segura nosso READ STREAM que foi criado por meio de '.createReadStream(localDoArquivo)'... ///file.pipe() é o negócio que VAI STREAMAR A 'CREATED DATA STREAM' PARA DENTRO DO OBJETO 'response' de nosso app... (objeto response é, BTW, uma 'WRITABLE STRING', e é exatamente POR CONTA DISSO QUE PODEMOS ESCREVER 'file.pipe(res)', podemos USÁ-LO COMO PARÂMETRO, para que os conteúdos da readable stream de 'file' consigams ser PIPEADAS a esse objeto-stream......)
      }
    }
  });
};






-----------------------------------






---> VOCÊ PRECISA INSTANCIAR 



ESSE 

CONSTRUCTOR...








--> COM ISSO, TEREMOS UM NOVO DOCUMENTO PDF....










---> A PARTE INTERESSANTE, AQUI, É QUE 





ESSE 'NOVO DOCUMENTO PDF'


TAMBÉM 

É 


CONSIDERADO 



UMA 

'READABLE STREAM'... ( exatamente como vimos 


com 


'const file = createReadStream(invoicePath)' 

)









------> PORTANTO, O QUE PODEMOS FAZER, AQUI, 


É 


__DIRECIONAR/FUNNELAR/PIPEAR 



ESSA 




'READABLE STREAM'



de 



'pdfDoc',



POR MEIO DO MÉTODO 


'.pipe()',




__ PARA__ DENTRO __ DE __ ALGUMA COISA___ (nesse caso, NÃO SERÁ A RESPONSE, propriamente dita... ainda que ela realmente seja um exemplo de WRITABLE STREAM...)







ex:









exports.getFatura = (req, res, next) => { /////VERSÃO DO CÓDIGO QUE __ FAZ AUTO-GENERATE DE PDFS para nossas faturas/invoices...
  const orderId = req.params.orderId; //necessário..
  const invoiceName = 'fatura-' + orderId + '.pdf'; 
  const invoicePath = `${pdfPath}/${invoiceName}`;


  Order.findById(ObjectId(orderId)).then((order) => {
    if (!order) {
      req.flash('error', 'Your order could not be found.')
      return res.redirect('/orders');
    } else {
      if (order.user.userId.toString() !== req.user._id.toString()) {
        req.flash('error', 'Your user was not responsible for that order.');
        return res.redirect('/orders');
      } else {

          const pdfDoc = new PDFDocument(); 




          pdfDoc.pipe()



-----------------------------------------













ACERTEI... O PROFESSOR VAI FAZER 'PIPE'

DESSE OUTPUT 


PARA DENTRO DE ALGUMA COISA... --------> 






MAS PARA QUAL COISA PIPEAREMOS 



ESSA 'readable stream' 



DE 'pdfDoc'? 










-----> BEM, A REGRA-GERAL 

DE 

READ-WRITE STREAMS 


É QUE 




READABLES STREAMS SEMPRE SÃO 'PIPEADAS'


PARA 

DENTRO 

DE 

'WRITABLE FILE STREAMS' (que podem OU NÃO ser a response, que é um exemplo de WRITABLE FILE STREAM...)











-----> para CONSEGUIRMOS UMA 'write stream aleatória',



PROFESSOR 




ESCREVE 


'fs.createWriteStream()' ------> 








createWriteStream



É UMA FUNÇÃO QUE PODEMOS CHAMAR 


NA PACKAGE DE 

'fileSystem' (fs)...





EX:








exports.getFatura = (req, res, next) => { /////VERSÃO DO CÓDIGO QUE __ FAZ AUTO-GENERATE DE PDFS para nossas faturas/invoices...
  const orderId = req.params.orderId; //necessário..
  const invoiceName = 'fatura-' + orderId + '.pdf'; 
  const invoicePath = `${pdfPath}/${invoiceName}`;


  Order.findById(ObjectId(orderId)).then((order) => {
    if (!order) {
      req.flash('error', 'Your order could not be found.')
      return res.redirect('/orders');
    } else {
      if (order.user.userId.toString() !== req.user._id.toString()) {
        req.flash('error', 'Your user was not responsible for that order.');
        return res.redirect('/orders');
      } else {

          const pdfDoc = new PDFDocument(); 

          pdfDoc.pipe(fs.createWriteStream());














-----> CERTO... MAS 


ESSA FUNÇÃO 

'createWriteStream()'


EXIGE 1 PARÂMETRO... ------> 








O PARÂMETRO É 



__ ''' O PATH EM QUE VAMOS QUERER FAZER WRITE__ 

DESSA STREAM''''





--> no caso, o professor coloca 

'invoicePath',




JUSTAMENTE 

PQ 




ELE QUER 

GARANTIR 



___ QUE __ O PDF_ QUE NÓS __ CRIAMOS _ AQUI __ TAMBÉM __


ACABE __ SENDO 

_ ARMAZENADO NO SERVER, por meio de um STREAM PROGRESSIVO( 



    ou seja,



    ACABAMOS COM 2 CÓPIAS DA MESMA FATURA:




    1 ACABA SERVIDA AO USER, RETORNADA A ELE;


    A OUTRA ACABA _ ARMAZENADA__ NO SERVER/APP EXPRESSJS,



    DENTRO DAQUELE FOLDER DE 'faturas'...

)






salvar no BACKEND 1 CÓPIA ---> 'pdfDoc.pipe(fs.createWriteStream(invoicePath))'

salvar NO PC DO USER UMA CÓPIA --> 'pdfDoc.pipe(res);'










-----> NO CASO, O CÓDIGO VAI FICANDO ASSIM:



const pdfPath = path.join(__dirname, '..', 'faturas');


exports.getFatura = (req, res, next) => { /////VERSÃO DO CÓDIGO QUE __ FAZ AUTO-GENERATE DE PDFS para nossas faturas/invoices...
  const orderId = req.params.orderId; //necessário..
  const invoiceName = 'fatura-' + orderId + '.pdf'; 
  const invoicePath = `${pdfPath}/${invoiceName}`;


  Order.findById(ObjectId(orderId)).then((order) => {
    if (!order) {
      req.flash('error', 'Your order could not be found.')
      return res.redirect('/orders');
    } else {
      if (order.user.userId.toString() !== req.user._id.toString()) {
        req.flash('error', 'Your user was not responsible for that order.');
        return res.redirect('/orders');
      } else {

          const pdfDoc = new PDFDocument(); 

          pdfDoc.pipe(fs.createWriteStream(invoicePath)); //////ESTE É O CÓDIGO EM QUESTÃO.
          pdfDoc.pipe(res)






------------------------------------













EX:






Syntax:

fs.createReadStream( path, options )
Parameters: This method accept two parameters as mentioned above and described below:

path: This parameter holds the path of the file where to read the file. It can be String, Buffer or URL.
options: It is an optional parameter that holds string or object.



-----------------



 





--> OK, 


ENTÃO VAMOS QUERER SALVAR UMA CÓPIA 


NO BACKEND/ APP NODEEXPRESS,



e outra 




VAMOS QUERER ENVIAR AO USER, POR MEIO DO 




'pipe' no OBJETO/WRITABLE STREAM 'response'...




EX:







          const pdfDoc = new PDFDocument(); 

          pdfDoc.pipe(fs.createWriteStream(invoicePath)); //////ESTE É O CÓDIGO EM QUESTÃO.
          pdfDoc.pipe(res)










--------> OK... AGORA TEMOS ESSE SETUP...








--> O PDF VAI SER ENVIADO, SIM, 



MAS ATÉ __AGORA__ ELE ESTÁ __ VAZIO....







--> VAMOS QUERER __ PREENCHER ELE, AGORA, COM A 

DATA 

DE 
NOSSA 'ORDER'....






--> 'WHATEVER WE ADD TO THE DOCUMENT WILL BE FORWARDED INTO THIS 


STREAM/FILE' (a file/stream criada com 'fs.createWriteStream()'...)




----->  E ESSA STREAM REALMENTE É 'GENERATED ON THE FLY',



JUNTO COM A 'RESPONSE'...









--> PROFESSOR DIZ QUE DEVEMOS COMEÇAR SIMPLES,

 

 E DEVEMOS 
 USAR 




 'pdfDoc' 


 E ENTÃO _CHAMAR__ O MÉTODO 

 '.text()'

 DENTRO DELE...












 EX:





          const pdfDoc = new PDFDocument(); 

          pdfDoc.pipe(fs.createWriteStream(invoicePath)); //////ESTE É O CÓDIGO EM QUESTÃO.
          pdfDoc.pipe(res);
          pdfDoc.text(); ///////EIS O CÓDIGO EM QUESTÃO.








-------------------------------








PdfDoc.text() ------> NOS DEIXA __ ADICIONAR 'A SINGLE LINE OF TEXT INTO THE PDF DOCUMENT' 





(obs:: 'pdfDoc' é literalmente uma INSTANCIAÇÃO DO OBJETO 'PDFDocument'..., criado com 'new PDFDocument()'...)








--> PROFESSOR TESTA COM 'Hello World'...







EX:







          const pdfDoc = new PDFDocument(); 

          pdfDoc.pipe(fs.createWriteStream(invoicePath)); //////ESTE É O CÓDIGO EM QUESTÃO.
          pdfDoc.pipe(res);
          pdfDoc.text('Hello World!'); ///////EIS O CÓDIGO EM QUESTÃO.











----> esses 'EDITS' por meio de coisas 

como 


'.text()'



´SO __ VÃO SER INCORPORADOS/SALVOS 

AO 



DOCUMENTO PDF criado com 'new PDFDocument()'



__quando 


CHAMARMOS 



O MÉTODO 


'pdfDoc.end()'







-------> É O MÉTODO 'end()' QUE INTERESSA...








--> QUANDO VOCÊ CHAMA '.end()',

ESSES 'WRITABLE STREAMS' (o primeiro e segundo pipes),




USADOS ___ PARA __ O CREATE DA FILE __ E PARA O SEND DA RESPONSE 

com essa file embutida,




ESSES 2 

WRITABLE STREAMS __ SERÃO 'CLOSED'...



(


  eles vao basicamente RECONHECER QUE 

  VOCÊ ESTÁ 'DONE WRITING'...
) -------> E A PARTIR DISSO,


A FILE VAI SER SAVED,

E 

A 

RESPONSE SERÁ ENVIADA...






EX:







const pdfDoc = new PDFDocument();

pdfDoc.pipe(fs.createWriteStream(invoicePath)); ////vai criar/armazenar esse pdf LÁ NO FILESYSTEM DO NOSSO APP NODEEXPRESS... lá na pasta 'faturas'... OBS: o documento pdf inicialmente estará em BRANCO, temos que editar por meio das linhas seguintes...
pdfDoc.pipe(res); ////É ISSO QUE VAI FORWARDAR/RETORNAR ESSE PDF AO USER, VAI DAR UMA CÓPIA DESSE PDF AO USER...

pdfDoc.text('Hello World');////NOS DEIXA ADICIONAR/INCORPORAR 1 LINHA DE TEXTO NO INTERIOR DESSE DOCUMENTO PDF que criamos com 'new PDFDocument()'....
pdfDoc.end(); ///É ISSO __ QUE ___ TERMINA/CONCLUI AS OPERAÇÕES DE WRITE nas 'writable streams' de  pdfDoc.pipe(fs.createWriteStream(invoicePath)); E pdfDoc.pipe(res); -------> VOCÊ DEVE CHAMAR 'pdfDoc.end()' PARA __ TERMINAR__ ESSE WRITE AÍ, O WRITE DO PDF, que será feito por meio de 'streams'...



      }
    }
  });













  CÓDIGO COMPLETO:











  
exports.getFatura = (req, res, next) => { /////VERSÃO DO CÓDIGO QUE __ FAZ AUTO-GENERATE DE PDFS para nossas faturas/invoices...
  const orderId = req.params.orderId; //necessário..
  const invoiceName = 'fatura-' + orderId + '.pdf'; 
  const invoicePath = `${pdfPath}/${invoiceName}`;
  console.log(invoiceName);
 
  Order.findById(ObjectId(orderId)).then((order) => {
    if (!order) {
        // console.log('ENTER');
      req.flash('error', 'Your order could not be found.')
      return res.redirect('/orders');
    } else {
      if (order.user.userId.toString() !== req.user._id.toString()) {
        // console.log(req.user._id, 'LINE5125');
        // console.log('ENTER2');
        req.flash('error', 'Your user was not responsible for that order.');
        return res.redirect('/orders');
      } else {
//         return fs.readFile(`${pdfPath}/${invoiceName}`, (err, data) => { ///////CÓDIGO RUIM, CÓDIGO QUE NÃO FAZ O 'STREAM OF DATA'... (ver aula 325....) --> DEVEMOS SEMPRE 'STREAM THE DATA', tudo para: 1) EVITAR O OVERFLOW DA MEMÓRIA TEMPORÁRIA DE NOSSO APP NODE, que será ocupada pelo READ e RETURN desses arquivos.... 2) EVITAR O ___ LONGO __ TEMPO ATÉ RECEBER UMA 'RESPONSE' POR PARTE DO SERVER....
//           if (err) {
//             return next(err);
//           } else {
//             console.log(data);
//             res.setHeader('Content-Type', 'application/pdf'); ////EIS O CÓDIGO EM QUESTÃO. Usamos esse código aí para __ ALTERAR O FILENAME do arquivo que o user vai baixar( pegar um filename mais simples) E TAMBÉM ____ PARA __ CONSEGUIR COLOCAR A EXTENSION DE '.pdf' ao nosso arquivo retornado... (se não fizermos isso, ele será BAIXADO COMO UM ARQUIVO SEM EXTENSÃO.. o que é um lixo...)
//             // res.setHeader('Content-Disposition', 'attachment' );  //////'inline' --> faz com que seja aberto um 'PDF VIEWER' no nosso browser, para visualizar esse arquivo (e dar a opção de o baixar, se o user quiser)... ---> entretanto, os nomes das files vão ficar zoados, vão ficar em um formato tipo ''61966d050dd562509c7febe7''  ------> o contrário de 'inline' é 'attachment', QUE É O VALOR QUE VAI FAZER COM QUE __ NOSSAS FILES SEJAM BAIXADAS DIRETAMENTE, sem abrir esse VISUALIZADOR DE PDF prévio....
//             res.setHeader('Content-Disposition', `inline; filename="${invoiceName}"` )
// //inline vs attachment; decida qual é o melhor para seu aplicativo, dependendo do caso concreto (queremos que o user baixe o arquivo sem qualquer conversinha? ou queremos que ele VISUALIZE O ARQUIVO no 'pdf viewer'/mp3 viewer do browser antes de o baixar? se quisermos essa lenga-lenga, devemos escrever 'inline')
//             return res.send(data); 
//           }
//         });


const pdfDoc = new PDFDocument();

pdfDoc.pipe(fs.createWriteStream(invoicePath)); ////vai criar/armazenar esse pdf LÁ NO FILESYSTEM DO NOSSO APP NODEEXPRESS... lá na pasta 'faturas'... OBS: o documento pdf inicialmente estará em BRANCO, temos que editar por meio das linhas seguintes...
pdfDoc.pipe(res); ////É ISSO QUE VAI FORWARDAR/RETORNAR ESSE PDF AO USER, VAI DAR UMA CÓPIA DESSE PDF AO USER...

pdfDoc.text('Hello World');////NOS DEIXA ADICIONAR/INCORPORAR 1 LINHA DE TEXTO NO INTERIOR DESSE DOCUMENTO PDF que criamos com 'new PDFDocument()'....
pdfDoc.end(); ///É ISSO __ QUE ___ TERMINA/CONCLUI AS OPERAÇÕES DE WRITE nas 'writable streams' de  pdfDoc.pipe(fs.createWriteStream(invoicePath)); E pdfDoc.pipe(res); -------> VOCÊ DEVE CHAMAR 'pdfDoc.end()' PARA __ TERMINAR__ ESSE WRITE AÍ, O WRITE DO PDF, que será feito por meio de 'streams'...



      }
    }
  });
};














-------> COM TUDO ISSO SALVO,







VAMOS TESTAR...








--> MAS ANTES DE TESTAR,

PRECISAMOS SETTAR NOSSOS RESPONSE HEADERS ADEQUADAMENTE (precisamos definir o NOME DA FILE QUE SERÁ SALVA E __ O TIPO __ DE FILE _ QUE SERÁ RETORNADA __ NA RESPONSE... DUAS COISAS QUE SÃO FEITAS COM HEADERS, com 'setHeader'...)




--> FAREMOS ISSO POR MEIO DOS CLÁSSICOS CÓDIGOS 

            res.setHeader('Content-Type', 'application/pdf'); 
      


      e 




            res.setHeader('Content-Disposition', `inline; filename="${invoiceName}"` )






---------------------------------------







ESCREVEMOS:







exports.getFatura = (req, res, next) => { /////VERSÃO DO CÓDIGO QUE __ FAZ AUTO-GENERATE DE PDFS para nossas faturas/invoices...
  const orderId = req.params.orderId; //necessário..
  const invoiceName = 'fatura-' + orderId + '.pdf'; 
  const invoicePath = `${pdfPath}/${invoiceName}`;
  console.log(invoiceName);
 
  Order.findById(ObjectId(orderId)).then((order) => {
    if (!order) {
        // console.log('ENTER');
      req.flash('error', 'Your order could not be found.')
      return res.redirect('/orders');
    } else {
      if (order.user.userId.toString() !== req.user._id.toString()) {
        // console.log(req.user._id, 'LINE5125');
        // console.log('ENTER2');
        req.flash('error', 'Your user was not responsible for that order.');
        return res.redirect('/orders');
      } else {



const pdfDoc = new PDFDocument();


res.setHeader('Content-Type', 'application/pdf');
   res.setHeader('Content-Disposition', `inline; filename="${invoiceName}"` )

pdfDoc.pipe(fs.createWriteStream(invoicePath)); ////vai criar/armazenar esse pdf LÁ NO FILESYSTEM DO NOSSO APP NODEEXPRESS... lá na pasta 'faturas'... OBS: o documento pdf inicialmente estará em BRANCO, temos que editar por meio das linhas seguintes...
pdfDoc.pipe(res); ////É ISSO QUE VAI FORWARDAR/RETORNAR ESSE PDF AO USER, VAI DAR UMA CÓPIA DESSE PDF AO USER...

pdfDoc.text('Hello World');////NOS DEIXA ADICIONAR/INCORPORAR 1 LINHA DE TEXTO NO INTERIOR DESSE DOCUMENTO PDF que criamos com 'new PDFDocument()'....
pdfDoc.end(); ///É ISSO __ QUE ___ TERMINA/CONCLUI AS OPERAÇÕES DE WRITE nas 'writable streams' de  pdfDoc.pipe(fs.createWriteStream(invoicePath)); E pdfDoc.pipe(res); -------> VOCÊ DEVE CHAMAR 'pdfDoc.end()' PARA __ TERMINAR__ ESSE WRITE AÍ, O WRITE DO PDF, que será feito por meio de 'streams'...



      }
    }
  });
};







----> SALVAMOS....






AGORA QUANDO CLICARMOS NO 'INVOICE LINK',


VAMOS RECEBER 

1 
PDF COM SÓ 1 LINHA DE TEXTO, DIZENDO 

'HELLO WORLD'...










---> E ESSE PDF TAMBÉM PODE SER ENCONTRADO LÁ NO FOLDER DE 'faturas',



salvo no filesystem de nosso servidor...










-------> OK.... 




É ASSIM QUE PODEMOS 'CREATE A PDF ON THE FLY'...







--> NA PRÓXIMA LIÇÃO VEREMOS _ COMO _'POPULATE' 

ESSE 

PDF 
COM 



A NOSSA 'ORDER DATA'..