







--------> NOSSO CÓDIGO, ATÉ AGORA, DO CONTROLLER DE 'LOGIN',


FICOU ASSIM:






exports.login = (req, res, next) => {
  const email = req.body.email;
  const password = req.body.password;
  let loadedUser;

  User.findOne({ email: email })
    .then((user) => {
      if (!user) {
        const error = new Error(
          'No user could be found for the entered email.'
        );
        error.statusCode = 404;
        throw error;
      }
      loadedUser = user; ///aqui armazenamos a data de nosso user naquela variável inicial... vamos o utilizar mais para baixo, em execuções dentro dessa promise chain...
      return compare(password, user.password);
    })
    .then((isEqual) => {
      if (!isEqual) {
        const error = new Error(
          'Invalid Password. Please try again.'
        );
        error.statusCode = 401; //'unauthenticated'...
        throw error;
      } else {


      }
    })
    .catch((err) => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }

      next(err);
    });
};














--_> SE O USER ENTRA NESTE BLOCK AQUI:



else {


      }










      ------> NÓS __ SABEMOS__ QUE ELE INPUTTOU 'VALID CREDENTIALS'....









------> AGORA VAMOS QUERER USAR ESSA INFO, 

ESSA 

DATA 

DAS VALID CREDENTIALS,

para 


'GENERATE A JSON WEB TOKEN',


exatamente como o professor nos mostrou nos slides:






1) JSON DATA  (é data javascript, no final das contas...)





+ 





2) UMA ASSINATURA (assinatura que é GERADA NO SERVER EM SI)... -------> É GERADO POR MEIO DE UMA 'SPECIAL PRIVATE KEY',



UMA KEY __ QUE __ SÓ __ FICA DISPONÍVEL/É DISPONÍVEL __ DENTRO 


DO 

SERVER EM SI...


(ASSINATURA PODE SER VERIFICADA PELO SERVER, POR MEIO DE KEY SECRETA...)




+ 





3) UMA 'JSON WEB TOKEN' (JWT) ------> 






ESSA 'JSON WEB TOKEN' 



É ENTÃO __ RETORNADA_ _ AO CLIENT,



e A
 



 'SIGNATURE',


 COMO O PROFESSOR EXPLICOU,






 _________ SÓ PODE __ SER VERIFICADA ___ PELO __ SERVER QUE 



 A CRIOU... --------> ISSO SIGNIFICA QUE 

 VOCÊ 


 NÃO CONSEGUE 

 'EDIT/CREATE'




 A TOKEN NO CLIENT DO USER/seu client... (


     BEM, VOCÊ PODE,

     MAS 

O SERVER VAI DETECTAR ESSA FUTRICAGEM,

E VAI 




TRATAR O TOKEN COMO INVÁLIDO...

 )







 -----------------------------------------



















 -------> PARA ISSO,

 QUITAMOS 


 O 



 SERVER DO NODE,

 E AÍ 



 INSTALAMOS UMA NOVA 





 PACKAGE...







 -> PACKAGE 

 DE 



 'jsonwebtoken' --------> 






 ex: 






 npm install --save jsonwebtoken











 ESSA É UMA __ PACKAGE__ QUE NOS _ DEIXA __ CONVENIENTEMENTE __ 



 CRIAR 



 'NEW JSON WEB TOKENS'...










 --> OK.... INSTALAMOS ESSE NEGÓCIO.... AGORA PRECISAMOS O IMPORTAR PARA DENTRO DO ARQUIVO 



 'auth.js'..











 -----> professor escreve:





 const jwt = require('jsonwebtoken') 








 AGORA TEMOS O OBJETO QUE ESSA PACKAGE EXPÕE....








 ex:






 const User = require('../models/user');

const { validationResult } = require('express-validator');

const { hash, compare } = require('bcryptjs');

const jwt = require('jsonwebtoken'); //necessário para o generate de JSON WEB TOKENS, para authenticate o user...

exports.signup = (req, res, next) => {
  const errors = validationResult(req);

  if (!errors.isEmpty()) {
    const error = new Error('Validation failed.');
    error.statusCode = 422;
    error.data = errors.array(); ///array com todos os errors ocorridos durante o validation.... ////esse pass de errors é totalmente opcional, mas é bom se você quer que o user/desenvolvedores tenham o array de errors na response, quando errors ocorrerem....
    throw error; //será capturado por nosso MAIN ERROR HANDLING MIDDLEWARE, lá em 'app.js'...
  }

  const email = req.body.email;
  const name = req.body.name;
  const password = req.body.password;

  hash(password, 12)
    .then((hashedPassword) => {
      const user = new User({
        email: email,
        name: name,
        password: hashedPassword,
      });

      return user.save(); ///retornamos para usar o then block subsequente....
    })
    .then((result) => {
      console.log(result);
      res.status(201).json({
        message: 'User was created successfully!',
        userId: result._id,
      });
    })
    .catch((err) => {
      console.log(err);
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.login = (req, res, next) => {
  const email = req.body.email;
  const password = req.body.password;
  let loadedUser;

  User.findOne({ email: email })
    .then((user) => {
      if (!user) {
        const error = new Error(
          'No user could be found for the entered email.'
        );
        error.statusCode = 404;
        throw error;
      }
      loadedUser = user; ///aqui armazenamos a data de nosso user naquela variável inicial... vamos o utilizar mais para baixo, em execuções dentro dessa promise chain...
      return compare(password, user.password);
    })
    .then((isEqual) => {
      if (!isEqual) {
        const error = new Error(
          'Invalid Password. Please try again.'
        );
        error.statusCode = 401; //'unauthenticated'...
        throw error;
      } else {


      }
    })
    .catch((err) => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }

      next(err);
    });
};
 







 --------------------------







 AGORA, LÁ NAQUELE ELSE BLOCK,








 VAMOS QUERER 


 'GENERATE A NEW TOKEN'...










 --> PARA ISSO,


 professor 



 vai 

 começar pela criação 


 de 



 ua constnate 






 de nome 


 'token'..









 --> AÍ ELE USA __ O PACOTE DE 'jwt',

 particularmente seu método 


 '.sign()'...








 Ex:








 const token = jwt.sign() ---------------> 










 --> ESSE MÉTODO AÍ VAI 'CREATE A NEW SIGNATURE' (assinatura),

 E AÍ __ 



 VAI 



 EMPACOTAR __ ESSA SIGNATURE __ EM 

 UMA 


 NOVA JSON WEB TOKEN... ------> 








 É EVIDENTE QUE 

 ESSE 

 'sign()'



 ACEITA/EXIGE UM PARÂMETRO,


 E NESSE 

 PARÂMETRO PODEMOS 


 INSERIR UM OBJETO.... DENTRO DO OBJETO, PODEMOS INSERIR QUALQUER 


 DATA QUE 

 QUISERMOS,







 COMO POR EXEMPLO O 'user email' (passamos 'loadedUser.email', usando aquela variável que críamos anteriormente)....








(


    no meu projeto nextjs,


    eu também havia feito o  store do USER EMAIL na token que retorna ao seu browser... acho que 


    é uma common practice...
)







---------> mas o professor também armazena 



outras coisas 

nessa web token,

como o 


'userId' (


    eu nunca tinha visto alguém fazer isso,

    com essa token
),








QUE ELE CONVERTE EM UMA STRING (pq vai ser 1 objeto, inicialmente, pois todos os '_id' no 

mongodb SÃO de formato 'ObjectId' )










--> professor só nos explica que 



'YOU SHOULD NEVER STORE THE RAW PASSWORD IN HERE,

BECAUSE THAT WOULD BE RETURNED TO THE FRONTEND/users'...




EX:









 const User = require('../models/user');

const { validationResult } = require('express-validator');

const { hash, compare } = require('bcryptjs');

const jwt = require('jsonwebtoken'); //necessário para o generate de JSON WEB TOKENS, para authenticate o user...

exports.signup = (req, res, next) => {
  const errors = validationResult(req);

  if (!errors.isEmpty()) {
    const error = new Error('Validation failed.');
    error.statusCode = 422;
    error.data = errors.array(); ///array com todos os errors ocorridos durante o validation.... ////esse pass de errors é totalmente opcional, mas é bom se você quer que o user/desenvolvedores tenham o array de errors na response, quando errors ocorrerem....
    throw error; //será capturado por nosso MAIN ERROR HANDLING MIDDLEWARE, lá em 'app.js'...
  }

  const email = req.body.email;
  const name = req.body.name;
  const password = req.body.password;

  hash(password, 12)
    .then((hashedPassword) => {
      const user = new User({
        email: email,
        name: name,
        password: hashedPassword,
      });

      return user.save(); ///retornamos para usar o then block subsequente....
    })
    .then((result) => {
      console.log(result);
      res.status(201).json({
        message: 'User was created successfully!',
        userId: result._id,
      });
    })
    .catch((err) => {
      console.log(err);
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.login = (req, res, next) => {
  const email = req.body.email;
  const password = req.body.password;
  let loadedUser;

  User.findOne({ email: email })
    .then((user) => {
      if (!user) {
        const error = new Error(
          'No user could be found for the entered email.'
        );
        error.statusCode = 404;
        throw error;
      }
      loadedUser = user; ///aqui armazenamos a data de nosso user naquela variável inicial... vamos o utilizar mais para baixo, em execuções dentro dessa promise chain...
      return compare(password, user.password);
    })
    .then((isEqual) => {
      if (!isEqual) {
        const error = new Error(
          'Invalid Password. Please try again.'
        );
        error.statusCode = 401; //'unauthenticated'...
        throw error;
      } else {

        const token = jwt.sign(
            {
                email: loadedUser.email, //////EIS O CÓDIGO EM QUESTÃO.
                userId: loadedUser._id.toString() //////EIS O CÓDIGO EM QUESTÃO.
            }
        )
      }
    })
    .catch((err) => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }

      next(err);
    });
};
 


--------------------------------------------------------







se você colocar o hashedPassword no web token (nunca faça isso),


só o user 

receberia 

esse 

token com essa info crucial,


MAS AINDA ASSIM, NÃO É NADA IDEAL FAZER ISSO...






-------> 







CRIADA ESSA TOKEN A PARTIR DESSAS INFO (email e userId),




  





  O PROFESSOR DIZ QUE DEVEMOS PASSAR 1 SEGUNDO PARÂMETRO 

  A 

  ESSE 



  método 

  '.sign()' ------>  




  O SEGUNDO 


  ARGUMENTO 



  SERÁ O ARGUMENTO 


  'secret',



  OU SEJA,

  A 

  'PRIVATE KEY' 


  QUE 



  __ SERÁ ___ USADA  PARA ___ FAZER O 'SIGINING'.... -----------> 








  E ESSA 


  PRIVATE KEY SERÁ 'ONLY KNOWN TO THE SERVER',


  o que 


  SIGNIFICA QUE 


  SERÁ __ IMPOSSÍVEL__ FAKAR 


  ESSA TOKEN LÁ NO CLIENT (na localStorage)...












  ----> NO CASO, 

  O PROFESSOR VAI 


  COLOCAR 'secret' (só essa palavrinha),


  MAS 


  TIPICAMENTE 

  VOCÊ 


  VAI USAR 


  STRINGS LONGAS,






talvez isto ajude:



  https://mkjwk.org/






  --> usarei esta:


  zVzS42wNmzOOmlRgYCNWE1dxTH4n_sL6JuDnNj2srF2B7YxRsAgVmvqO8z14Wd3nzOqXzseBAjJ7PA5RSzjs0GsdrR5nxrVu8NPQJjooJLq2GqEl4h9JxwJ8zg5d_Fl2l3Q3n8yf13Gydum25V3mYRUy--L1EskSMs2PcEXLOJM















  exports.signup = (req, res, next) => {
  const errors = validationResult(req);

  if (!errors.isEmpty()) {
    const error = new Error('Validation failed.');
    error.statusCode = 422;
    error.data = errors.array(); ///array com todos os errors ocorridos durante o validation.... ////esse pass de errors é totalmente opcional, mas é bom se você quer que o user/desenvolvedores tenham o array de errors na response, quando errors ocorrerem....
    throw error; //será capturado por nosso MAIN ERROR HANDLING MIDDLEWARE, lá em 'app.js'...
  }

  const email = req.body.email;
  const name = req.body.name;
  const password = req.body.password;

  hash(password, 12)
    .then((hashedPassword) => {
      const user = new User({
        email: email,
        name: name,
        password: hashedPassword,
      });

      return user.save(); ///retornamos para usar o then block subsequente....
    })
    .then((result) => {
      console.log(result);
      res.status(201).json({
        message: 'User was created successfully!',
        userId: result._id,
      });
    })
    .catch((err) => {
      console.log(err);
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.login = (req, res, next) => {
  const email = req.body.email;
  const password = req.body.password;
  let loadedUser;

  User.findOne({ email: email })
    .then((user) => {
      if (!user) {
        const error = new Error(
          'No user could be found for the entered email.'
        );
        error.statusCode = 404;
        throw error;
      }
      loadedUser = user; ///aqui armazenamos a data de nosso user naquela variável inicial... vamos o utilizar mais para baixo, em execuções dentro dessa promise chain...
      return compare(password, user.password);
    })
    .then((isEqual) => {
      if (!isEqual) {
        const error = new Error(
          'Invalid Password. Please try again.'
        );
        error.statusCode = 401; //'unauthenticated'...
        throw error;
      } else {

        const token = jwt.sign(  ///// PRIMEIRO ARGUMENTO = DATA QUE VOCê QUER QUE SEJA RETORNADA, NA SUA JSON WEB TOKEN, AO USER (nunca coloque o hashedPassword, essa é a única regra... common practice é retornar o email...) 
                                  //////SEGUNDO ARGUMENTO = 'SECRET', OU A 'PRIVATE KEY' usada no GENERATE DA ASSINATURA (signature) dessa JSON WEB TOKEN --> É BOM USAR STRINGS ALEATÓRIAS E BEM LONGAS, para deixar seguro.... use o site mkjwk.org....
          {
            email: loadedUser.email,
            userId: loadedUser._id
          },
         'zVzS42wNmzOOmlRgYCNWE1dxTH4n_sL6JuDnNj2srF2B7YxRsAgVmvqO8z14Wd3nzOqXzseBAjJ7PA5RSzjs0GsdrR5nxrVu8NPQJjooJLq2GqEl4h9JxwJ8zg5d_Fl2l3Q3n8yf13Gydum25V3mYRUy--L1EskSMs2PcEXLOJM' //private key/secret ---> SERÁ CONHECIDA APENAS PELO SERVER...
        )

      }
    })
    .catch((err) => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }

      next(err);
    });
};











---------------------------------





CERTO...







E O PROFESSOR TBM SETTARÁ UM TERCEIRO ARGUMENTO,









ARGUMENTO QUE É USADO PARA __ CONFIGURAR___ ESSA 

JSON WEB TOKEN.... ----> NELA, 

O PROFESSOR 


SETTA 


UM 


'expiry time',




por meio da key 


'expiresIn' ----> 



ELE VAI 


DEFINIR UM TEMPO DE 

3600 segundos (1 hora)... ------> MAS EU ERREI.... -> A SINTAXE 

UTILIZADA 

É 



'1h' (uma string dizendo '1h') 




--> ISSO QUER DIZER QUE 
ESSA TOKEN VAI SE TORNAR INVÁLIDA 



APÓS 




1 HORA....





EX:











  exports.signup = (req, res, next) => {
  const errors = validationResult(req);

  if (!errors.isEmpty()) {
    const error = new Error('Validation failed.');
    error.statusCode = 422;
    error.data = errors.array(); ///array com todos os errors ocorridos durante o validation.... ////esse pass de errors é totalmente opcional, mas é bom se você quer que o user/desenvolvedores tenham o array de errors na response, quando errors ocorrerem....
    throw error; //será capturado por nosso MAIN ERROR HANDLING MIDDLEWARE, lá em 'app.js'...
  }

  const email = req.body.email;
  const name = req.body.name;
  const password = req.body.password;

  hash(password, 12)
    .then((hashedPassword) => {
      const user = new User({
        email: email,
        name: name,
        password: hashedPassword,
      });

      return user.save(); ///retornamos para usar o then block subsequente....
    })
    .then((result) => {
      console.log(result);
      res.status(201).json({
        message: 'User was created successfully!',
        userId: result._id,
      });
    })
    .catch((err) => {
      console.log(err);
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.login = (req, res, next) => {
  const email = req.body.email;
  const password = req.body.password;
  let loadedUser;

  User.findOne({ email: email })
    .then((user) => {
      if (!user) {
        const error = new Error(
          'No user could be found for the entered email.'
        );
        error.statusCode = 404;
        throw error;
      }
      loadedUser = user; ///aqui armazenamos a data de nosso user naquela variável inicial... vamos o utilizar mais para baixo, em execuções dentro dessa promise chain...
      return compare(password, user.password);
    })
    .then((isEqual) => {
      if (!isEqual) {
        const error = new Error(
          'Invalid Password. Please try again.'
        );
        error.statusCode = 401; //'unauthenticated'...
        throw error;
      } else {

        const token = jwt.sign(  ///// PRIMEIRO ARGUMENTO = DATA QUE VOCê QUER QUE SEJA RETORNADA, NA SUA JSON WEB TOKEN, AO USER (nunca coloque o hashedPassword, essa é a única regra... common practice é retornar o email...) 
                                  //////SEGUNDO ARGUMENTO = 'SECRET', OU A 'PRIVATE KEY' usada no GENERATE DA ASSINATURA (signature) dessa JSON WEB TOKEN --> É BOM USAR STRINGS ALEATÓRIAS E BEM LONGAS, para deixar seguro.... use o site mkjwk.org....
          {
            email: loadedUser.email,
            userId: loadedUser._id
          },
         'zVzS42wNmzOOmlRgYCNWE1dxTH4n_sL6JuDnNj2srF2B7YxRsAgVmvqO8z14Wd3nzOqXzseBAjJ7PA5RSzjs0GsdrR5nxrVu8NPQJjooJLq2GqEl4h9JxwJ8zg5d_Fl2l3Q3n8yf13Gydum25V3mYRUy--L1EskSMs2PcEXLOJM', //private key/secret ---> SERÁ CONHECIDA APENAS PELO SERVER...

         {
             expiresIn: '1h' ////////EIS O CÓDIGO EM QUESTÃO.
         }
        )

      }
    })
    .catch((err) => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }

      next(err);
    });
};











https://github.com/auth0/node-jsonwebtoken









---------------------------


CERTO... colocado esse secret aí no lugar,





E COLOCADO ESSE EXPIRY TIME DE expiresIn,















PROSSEGUIMOS...










---> PROFESSOR EXPLICA QUE O TEMPO LIMITE DA TOKEN É UM MECANISMO 

BOM DE SER ADICIONADO,

ISSO 

PQ 


O 

'TOKEN'


SEMPRE 

SERÁ 

___ARMAZENADO NO CLIENT__ DO USER... ------> é CLARO 



QUE 


ESSE 


TOKEN SERÁ ARMAZENADO 


'NO CLIENT A QUE ESSE TOKEN PERTENCE'.... ---------> MAS,

 

 TECNICAMENTE,


 ESSE ___ TOKEN ___ PODERIA/PODE ___ SER 




 __ROUBADO__ __.... 








 PODE SER ROUBADO SE:



 1) O USER NÃO FAZ 'LOGOUT' E OUTRA PESSOA __ COPIA__ ESSE TOKEN 

 LÁ DO BROWSER STORAGE DESSE USER...








 -----> SE VOCÊ NÃO TIVESSE COLOCADO 

 ESSE MECANISMO DE SEGURANÇA 

 DE 

 'expiresIn: 1h' ,


 ESSE 

 USUÁRIO MALICIOSO PODERIA 

 UTILIZAR ESSA TOKEN 

 ROUBADA __ PARA SEMPRE___... --> mas com 



 esse mecanismo 

 de segurança,

 a token 




 vai 


 expirar depois de 1 hora,




 EVITANDO QUE ISSO ACONTEÇA... --------> É UM 




 BOM MECANISMO 

 DE 

 SEGURANÇA,

 UM BOM 



 EQUILÍBRIO 


 ENTRE 


 USABILIDADE 



 e 



 SEGURANÇA...






 (1 hora é uma boa medida, e bem comum)...











 --> OK, AGORA TEMOS UMA TOKEN 

 QUE 

 VAMOS RETORNAR AO CLIENT...









 -->  PARA ISSO,

 PARA RETORNAR ESSA TOKEN AO CLIENT,


 PROFESSOR COMEÇA ESCREVENDO 


 'res.status(200).json(
     {

     }
 )'










 ----> PROFESSOR EXPLICA QUE PODERÍAMOS ENVIAR DE VOLTA UMA MESSAGE,


 MAS O QUE 

 INTERESSA,

 AQUI,

 É 



 O ANEXAMENTO 


 DE 


 NOSSA JWT, json web token.... (representada por 'token')....




---> por alguma RAZÃO BIZARRA, ELE TAMBÉM 

VAI 


ANEXAR uma key de 'userId',


COM UM VALOR DE 

'loadedUser._id.toString()' 



  







  ----> 


  EX:



  else {

        const token = jwt.sign(  ///// PRIMEIRO ARGUMENTO = DATA QUE VOCê QUER QUE SEJA RETORNADA, NA SUA JSON WEB TOKEN, AO USER (nunca coloque o hashedPassword, essa é a única regra... common practice é retornar o email...) 
                                  //////SEGUNDO ARGUMENTO = 'SECRET', OU A 'PRIVATE KEY' usada no GENERATE DA ASSINATURA (signature) dessa JSON WEB TOKEN --> É BOM USAR STRINGS ALEATÓRIAS E BEM LONGAS, para deixar seguro.... use o site mkjwk.org....
          {
            email: loadedUser.email,
            userId: loadedUser._id
          },
         'zVzS42wNmzOOmlRgYCNWE1dxTH4n_sL6JuDnNj2srF2B7YxRsAgVmvqO8z14Wd3nzOqXzseBAjJ7PA5RSzjs0GsdrR5nxrVu8NPQJjooJLq2GqEl4h9JxwJ8zg5d_Fl2l3Q3n8yf13Gydum25V3mYRUy--L1EskSMs2PcEXLOJM', //private key/secret ---> SERÁ CONHECIDA APENAS PELO SERVER...

         {
             expiresIn: '1h' ////////EIS O CÓDIGO EM QUESTÃO.
         }
        )


    res.status(200).json(
        {
            token: token,
            userId: loadedUser._id.toString(); 
        }
    )
      }





------------------------






OK, ENVIAR A TOKEN 



EU ENTENDO,



MAS PQ 

ENVIAR 

ESSE 

'userId'? --------> É 


PQ 



NO REACT APP,




NO CÓDIGO QUE O PROFESSOR ESCREVEU,




NOSSO FRONTEND 


VAI ESTAR __ PROCURANDO __ POR ESSE ID... ---->  E NESSE FRONTEND,

O PROFESSOR 


VAI 

ESTAR 

'STORING' ESSE 

ID 



NO 'STATE LOCAL' do frontend...  ------> ALÉM DISSO,



VOCê DEVE 

ANOTAR EM ALGUM LUGAR QUE 

VOCÊ 

VAI TER UMA TOKEN 

DE 

1 HORA,

para que 


SEU APP REACT __ AUTOMATICAMENTE__ FAÇA 'LOGOUT' 


QUANDO 

ESSE PERÍODO DE 1 HORA TIVER TRANSCORRIDO... (em algum 'logoutHandler', em 'App.js' do seu frontend...)









---------> E TODO ESSE STORING DE DADOS,




STORE 


DESSA __TOKEN__ E DESSE USERID ___ 

LÁ 



NO STORAGE DO BROWSER,

TUDO ISSO AÍ,


__SERÁ __ fEITO __ PELO FRONTEND.... (


    aaah... agora as coisas estão começando a fazer mais sentido...


)










-----> o professor provavelmetne vai usar aqueles methods de 



'localStorage.setItem()',




e 


'localStorage.getItem()'...













----> ok...



NOSSO CÓDIGO COMPLETO FICA ASSIM:














  exports.signup = (req, res, next) => {
  const errors = validationResult(req);

  if (!errors.isEmpty()) {
    const error = new Error('Validation failed.');
    error.statusCode = 422;
    error.data = errors.array(); ///array com todos os errors ocorridos durante o validation.... ////esse pass de errors é totalmente opcional, mas é bom se você quer que o user/desenvolvedores tenham o array de errors na response, quando errors ocorrerem....
    throw error; //será capturado por nosso MAIN ERROR HANDLING MIDDLEWARE, lá em 'app.js'...
  }

  const email = req.body.email;
  const name = req.body.name;
  const password = req.body.password;

  hash(password, 12)
    .then((hashedPassword) => {
      const user = new User({
        email: email,
        name: name,
        password: hashedPassword,
      });

      return user.save(); ///retornamos para usar o then block subsequente....
    })
    .then((result) => {
      console.log(result);
      res.status(201).json({
        message: 'User was created successfully!',
        userId: result._id,
      });
    })
    .catch((err) => {
      console.log(err);
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.login = (req, res, next) => {
  const email = req.body.email;
  const password = req.body.password;
  let loadedUser;

  User.findOne({ email: email })
    .then((user) => {
      if (!user) {
        const error = new Error(
          'No user could be found for the entered email.'
        );
        error.statusCode = 404;
        throw error;
      }
      loadedUser = user; ///aqui armazenamos a data de nosso user naquela variável inicial... vamos o utilizar mais para baixo, em execuções dentro dessa promise chain...
      return compare(password, user.password);
    })
    .then((isEqual) => {
      if (!isEqual) {
        const error = new Error(
          'Invalid Password. Please try again.'
        );
        error.statusCode = 401; //'unauthenticated'...
        throw error;
      } else {

        const token = jwt.sign(  ///// PRIMEIRO ARGUMENTO = DATA QUE VOCê QUER QUE SEJA RETORNADA, NA SUA JSON WEB TOKEN, AO USER (nunca coloque o hashedPassword, essa é a única regra... common practice é retornar o email...) 
                                  //////SEGUNDO ARGUMENTO = 'SECRET', OU A 'PRIVATE KEY' usada no GENERATE DA ASSINATURA (signature) dessa JSON WEB TOKEN --> É BOM USAR STRINGS ALEATÓRIAS E BEM LONGAS, para deixar seguro.... use o site mkjwk.org....
          {
            email: loadedUser.email,
            userId: loadedUser._id
          },
         'zVzS42wNmzOOmlRgYCNWE1dxTH4n_sL6JuDnNj2srF2B7YxRsAgVmvqO8z14Wd3nzOqXzseBAjJ7PA5RSzjs0GsdrR5nxrVu8NPQJjooJLq2GqEl4h9JxwJ8zg5d_Fl2l3Q3n8yf13Gydum25V3mYRUy--L1EskSMs2PcEXLOJM', //private key/secret ---> SERÁ CONHECIDA APENAS PELO SERVER...

         {
             expiresIn: '1h' ////////EIS O CÓDIGO EM QUESTÃO.
         }
        )

            res.status(200).json(
        {
            token: token,
            userId: loadedUser._id.toString(); 
        }
    )
      }



      }
    })
    .catch((err) => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }

      next(err);
    });
};




------------------------------------







OK.... O PROFESSOR ENTÃO VOLTA AO ARQUIVO
 

 'auth.js'



 de 

'routes'...











--> AÍ ELE 

CONECTA 



ESSE CONTROLLER de 'login',

tipo assim:





router.post('/login', authController.login);













----------> OK... AGORA NOSSA TAREFA É __ 



MANAGEAR  __ ESSA 

JSON WEB TOKEN,

CONTIDA NA NOSSA RESPONSE DO BACKEND,




LÁ 


NO FRONTEND... 









----> em que lugar do codigo está o receive desse 'auth' aí?







ESTÁ AQUI, EM 'loginHandler', lá em 'App.js':







  loginHandler = (event, authData) => {
    event.preventDefault();
    this.setState({ authLoading: true });
    fetch('URL')
      .then((res) => {
        if (res.status === 422) {
          throw new Error('Validation failed.');
        }

        if (res.status !== 200 && res.status !== 201) {
          throw new Error('Could not authenticate you!');
        }

        return res.json();
      })
      .then((data) => {
        console.log(data);

        this.setState({
          isAuth: true,
          token: data.token,
          authLoading: false,
          userId: data.userId,
        });
        localStorage.setItem('token', data.token);
        localStorage.setItem('userId', data.userId);
        const remainingMilliseconds = 60 * 60 * 1000; ///3600 segundos, 1 hora.
        const expiryDate = new Date(
          new Date().getTime() + remainingMilliseconds
        );
        localStorage.setItem('expiryDate', expiryDate.toISOString());
        this.setAutoLogout(remainingMilliseconds);
      })
      .catch((err) => {
        console.log(err);
        this.setState({
          isAuth: false,
          authLoading: false,
          error: err,
        });
      });
  };



--------------------------


ok... nesse local aí,




temos que 

PASSAR O PATH/URL 



de nossa route 

de 



'login'...





---> SERÁ ASSIM:







  loginHandler = (event, authData) => {
    event.preventDefault();
    this.setState({ authLoading: true });
    fetch('http://localhost:8080/auth/login') ///EIS O CÓDIGO EM QUESTÃO.
      .then((res) => {
        if (res.status === 422) {
          throw new Error('Validation failed.');
        }

        if (res.status !== 200 && res.status !== 201) {
          throw new Error('Could not authenticate you!');
        }

        return res.json();
      })
      .then((data) => {
        console.log(data);

        this.setState({
          isAuth: true,
          token: data.token,
          authLoading: false,
          userId: data.userId,
        });
        localStorage.setItem('token', data.token);
        localStorage.setItem('userId', data.userId);
        const remainingMilliseconds = 60 * 60 * 1000; ///3600 segundos, 1 hora.
        const expiryDate = new Date(
          new Date().getTime() + remainingMilliseconds
        );
        localStorage.setItem('expiryDate', expiryDate.toISOString());
        this.setAutoLogout(remainingMilliseconds);
      })
      .catch((err) => {
        console.log(err);
        this.setState({
          isAuth: false,
          authLoading: false,
          error: err,
        });
      });
  };






  -------------------------------







  OK... MAS __ ALGUMAS COISAS __ ESTÃO FALTANDO__ 



  NESSE 

  'loginHandler'.... 






  --> PRECISAMOS 



  COLOCAR A DATA RELATIVA AOS INPUTS DO USER 




  dentro 




  DO SEGUNDO PARÂMETRO DAQUELE 'fetch',


  E AÍ 

  também 



  settar 



  'body: JSON.stringify(...)',




  E AÍ 



  COLOCAR 'headers: {}' 





  como 


  'Content-Type: application/json'...,





  E ÁI __ TAMBÉM 

  PRECISAMOS DEFINIR O 'METHOD' 


  como 

  'POST'...





  --> SÓ ASSIM ESSE REQUEST ATINGIRÁ NOSSO 


  BACKEND NODEEXPRESS...







  ex:









  


  loginHandler = (event, authData) => {
    event.preventDefault();
    this.setState({ authLoading: true });
    fetch('http://localhost:8080/auth/login', ///EIS O CÓDIGO EM QUESTÃO.
    
    
    {
body: JSON.stringify(
    email: authData.email,
    password: authData.password
),
headers: {
    'Content-Type': 'application/json'
},
method: 'POST'
                        ///EIS O CÓDIGO EM QUESTÃO.

    }) 
      .then((res) => {
        if (res.status === 422) {
          throw new Error('Validation failed.');
        }

        if (res.status !== 200 && res.status !== 201) {
          throw new Error('Could not authenticate you!');
        }

        return res.json();
      })
      .then((data) => {
        console.log(data);

        this.setState({
          isAuth: true,
          token: data.token,
          authLoading: false,
          userId: data.userId,
        });
        localStorage.setItem('token', data.token);
        localStorage.setItem('userId', data.userId);
        const remainingMilliseconds = 60 * 60 * 1000; ///3600 segundos, 1 hora.
        const expiryDate = new Date(
          new Date().getTime() + remainingMilliseconds
        );
        localStorage.setItem('expiryDate', expiryDate.toISOString());
        this.setAutoLogout(remainingMilliseconds);
      })
      .catch((err) => {
        console.log(err);
        this.setState({
          isAuth: false,
          authLoading: false,
          error: err,
        });
      });
  };


-------------------------








CERTO... AGORA DEVO ANALISAR O RESTO DO CÓDIGO...








EX:




.then((data) => {
        console.log(data);

        this.setState({
          isAuth: true,
          token: data.token,
          authLoading: false,
          userId: data.userId,
        });
        localStorage.setItem('token', data.token);
        localStorage.setItem('userId', data.userId);
        const remainingMilliseconds = 60 * 60 * 1000; ///3600 segundos, 1 hora.
        const expiryDate = new Date(
          new Date().getTime() + remainingMilliseconds
        );
        localStorage.setItem('expiryDate', expiryDate.toISOString());
        this.setAutoLogout(remainingMilliseconds);
      })
      .catch((err) => {
        console.log(err);
        this.setState({
          isAuth: false,
          authLoading: false,
          error: err,
        });
      });
  };










  --> o professor já codou a maior parte 

  da lógica necessária...







  --> esta linha aqui:



          this.setState({
          isAuth: true,
          token: data.token,
          authLoading: false,
          userId: data.userId,
        });




--> vai cuidar da nossa interface.. (e vai se utilizar da RESPONSE, pq 

usa 'data.userId'... ) 






-------> a token é essencial, e tbm vai ser extraída da response... 



--> mesma coisa com o 'userId'...







certo...






depois disso,

temos esta linha:




    localStorage.setItem('token', data.token);
        localStorage.setItem('userId', data.userId);
        const remainingMilliseconds = 60 * 60 * 1000; ///3600 segundos, 1 hora.
        const expiryDate = new Date(
          new Date().getTime() + remainingMilliseconds
        );
        localStorage.setItem('expiryDate', expiryDate.toISOString());
        this.setAutoLogout(remainingMilliseconds);
      })




-----> essas linhas vão SETTAR 



ESSA TOKEN 


NO LOCALSTORAGE DO USER....  ----> vao settar o token e o userId....




--> também INICIAM 

AQUELA FUNÇÃO/MÉTODO 

de 

'autoLogout',



QUE DEPENDE 


DE 'remainingMilliseconds' (que serão 3600000, ou seja, 1 hora)....





------> A FUNÇÃO DE 'setAutoLogout',


POR SUA VEZ,

TEM ESTA SINTAXE:






  setAutoLogout = (milliseconds) => {
    setTimeout(() => {
      this.logoutHandler();
    }, milliseconds);
  };












-----> isso, na verdade,


é um código ___BEM PARECIDO COM AQUELE __ 



DE AUTHENTICATION QUE EU ESCREVI 

NO CURSO DE 



NEXTJS,

e 
de 

REACTJS....





--> NO NEXTJS, eu acho que 


não havia codado esse 'expiresIn'...





--> no nextjs,




o 'expiresIn' 


de meu token estava como 3 horas.... --> só não sei a razão disso... -->
 


 como alterar esse valor? é uma boa pergunta...











 AGORA DESCOBRI:







 VEJA OS DOCS:


 https://next-auth.js.org/configuration/options#jwt










 --> NAQUELE OBJETO 'options',



 QUE É ESTE AQUI:













 import NextAuth from 'next-auth';

import Providers from 'next-auth/providers';
import { verifyPassword } from '../../../../helpers/auth';
import { connectToDatabase } from '../../../../helpers/db-util';

// export default NextAuth();

export default NextAuth({
  ///CONFIG OBJECT. É necessário para definir o COMPORTAMENTO DO 'NEXTAUTH'..

  providers: [
    //o valor desse negócio SEMPRE SERÁ UM ARRAY....
    Providers.Credentials({
      async authorize(credentials) {
        const client = await connectToDatabase();

        const usersCollection = client.db().collection('users');

        const user = await usersCollection.findOne({
          email: credentials.email,
        });

        if (!user) {
          ///esse erro é atirado no case em que AQUELE EMAIL NÃO EXISTE NA NOSSA DATABASe...
          client.close();
          throw new Error('No user found for that email!'); //////o comportamento DEFAULT do nextauth é REDIRECIONAR O VISITANTE A UMA PÁGINA DIFERENTE DA QUE ESTÁ __ QUANDO __ É ATIRADO (throw) um ERROR dentro de 'authorize'... ---> mas nós vamos OVERWRITTAR ESSE COMPORTAMENTO; FAREMOS COM QUE A MENSAGEM/AS MENSAGENS DE ERRO __ SEJAM DISPLAYED__ NA MESMA PÁGINA EM QUE ELE ESTÁ (lá na signin form, essencialmente)...
        }

        const passwordIsValid = await verifyPassword(
          credentials.password,
          user.password
        );

        if (!passwordIsValid) {
            client.close(); ///CHAMAMOS ISSO __ ANTES_ DO THROW DO ERROR...
          throw new Error('Invalid Password, please try again.');
        }

        

        client.close();


if (passwordIsValid) {
  return {  ////////ISSO AQUI SERÁ NOSSO 'ACTUAL JSON WEB TOKEN' (JWT)... ---> ESSE OBJETO AQUI, retornado ao FINAL DO METHOD/FUNÇÃO 'authorize', É O QUE VAI SER CONSIDERADO/EMBUTIDO/TRANSFORMADO EM UMA WEBTOKEN, que será fornecida/retornada ao browser do usuário, caso ele seja autenticado com sucesso... --> esse objeto aí vai ser 'ENCODED IN A JSON WEB TOKEN'....
    email: user.email  //vamos retornar só o EMAIl do usuário na nossa json web token, e NÃO O 'hashed password' contido na nossa database, pq isso é inseguro, exporíamos um pouco o usuário (apesar de esse password ser hashed/encriptado....)
}
}
      

        // client.close(); ////CHAMAR ANTES __ DO RETURN DO 'JWT', e não depois....
      },
    }),
  ],
});











------> dentro desse objeto '{}' do 'NextAuth',



TEMOS 



VAAARIAS 

propriedades..



são elas:







- providers 

-database 


- secret 

-session 

-jwt 

-pages 

-callbacks 


-events 

-adapter 


-debug 


-logger 

-theme 


-useSecureCookies 

-cookies 









-------> no caso, SE QUEREMOS EDITAR O 'EXPIRY DATE' 


de nossa token,


PODEMOS SIMPLESMENTE ESCREVER ALGO ASSIM:



jwt: {
  // A secret to use for key generation. Defaults to the top-level `session`.
  secret: 'INp8IvdIyeMcoGAgFGoA61DdBglwwSqnXJZkgz8PSnw',
  // The maximum age of the NextAuth.js issued JWT in seconds.
  // Defaults to `session.maxAge`.
  maxAge: 60 * 60 * 24 * 30,
  // You can define your own encode/decode functions for signing and encryption
  // if you want to override the default behaviour.
  async encode({ secret, token, maxAge }) {},
  async decode({ secret, token, maxAge }) {},
}






TENTEI 

ALTERAR ESSE VALOR, MAS AINDA ASSIM,

NÃO FUNCIONOU...







--> talvez o correto seria 

mexer 



na propriedade de 'session'?




session: {
  // Choose how you want to save the user session.
  // The default is `"jwt"`, an encrypted JWT (JWE) in the session cookie.
  // If you use an `adapter` however, we default it to `"database"` instead.
  // You can still force a JWT session by explicitly defining `"jwt"`.
  // When using `"database"`, the session cookie will only contain a `sessionToken` value,
  // which is used to look up the session in the database.
  strategy: "database",

  // Seconds - How long until an idle session expires and is no longer valid.
  maxAge: 30 * 24 * 60 * 60, // 30 days

  // Seconds - Throttle how frequently to write to database to extend a session.
  // Use it to limit write operations. Set to 0 to always update the database.
  // Note: This option is ignored if using JSON Web Tokens
  updateAge: 24 * 60 * 60, // 24 hours
}












VOU TENTAR ISSO...









não, mas não é aí...









--> PROVAVELMENTE É NESTE LUGAR, NA CLIENT API:





{
  user: {
    name: string
    email: string
    image: string
  },
  expires: Date // This is the expiry of the session, not any of the tokens within the session
}




--> NA VERDADE,


É ESTA PROPRIEDADE AQUI:



    session: {
      maxAge: 15,
    }










    --> mas ela é extremamente bugada, e parece ter um limite de 4-3 horas... --> na verdade,



    ela FUNCIONA... --> FUNCIONA,



    mas 


 o indicador lá em 


 'application > storage --> cookies' (no chrome dev tools)


 MOSTRA 




 INFORMAÇÕES ERRADAS ACERCA DO TEMPO DE EXPIRAÇÃO.... 


 (



     não sei a razão disso... mas 

     o que interessa é que podemos, sim, controlar 

     o 

     expiry date por meio desse 'maxAge' --> o tempo que você escreve em 

     'maxAge' é 

     considerado em SEGUNDOS,

     portanto 1 hora é 3600 segundos...
 )









 sim... é isso mesmo. agora faz sentido.












 --_. ok.... 






 AGORA 

 VAMOS 

 QUERER 

 TESTAR,

 VER 

 SE 

 CONSEGUIMOS
  

  'AUTHENTICATE'


  nosso user (

    ou seja,

    CRIAR 1 USER, POR MEIO DA ROUTE 
    DE 

    'SIGNUP',

    e 
  


  AÍ 'login' esse user,


  por meio dessa 

  route de 

  login,

  com esse generate E STORE__ DESSA 


  WEBTOKEN..
  )










  --------> OK... 










  -----> 

  MAS O PROFESSOR DÁ UMA TRABALHADINHA NO FRONTEND....











  LÁ NO SIGNUPHANDLER,





  professor escreve 



  basicamente o que eu escrevi....:












  loginHandler = (event, authData) => {
    event.preventDefault();
    this.setState({ authLoading: true });
    fetch('http://localhost:8080/auth/login', ///EIS O CÓDIGO EM QUESTÃO.
    
    
    {
body: JSON.stringify(
    email: authData.email,
    password: authData.password
),
headers: {
    'Content-Type': 'application/json'
},
method: 'POST'
                        ///EIS O CÓDIGO EM QUESTÃO.

    }) 
      .then((res) => {
        if (res.status === 422) {
          throw new Error('Validation failed.');
        }

        if (res.status !== 200 && res.status !== 201) {
          throw new Error('Could not authenticate you!');
        }

        return res.json();
      })
      .then((data) => {
        console.log(data);

        this.setState({
          isAuth: true,
          token: data.token,
          authLoading: false,
          userId: data.userId,
        });
        localStorage.setItem('token', data.token);
        localStorage.setItem('userId', data.userId);
        const remainingMilliseconds = 60 * 60 * 1000; ///3600 segundos, 1 hora.
        const expiryDate = new Date(
          new Date().getTime() + remainingMilliseconds
        );
        localStorage.setItem('expiryDate', expiryDate.toISOString());
        this.setAutoLogout(remainingMilliseconds);
      })
      .catch((err) => {
        console.log(err);
        this.setState({
          isAuth: false,
          authLoading: false,
          error: err,
        });
      });
  };










  --------------------------------------


















  ------> ok...

   



   HÁ OUTRO AJUSTE QUE 

   O 

   PROFESSOR 


   FAZ.... ----->  ele 

   diz que podemos 



   optar pela escrita de 


   'authData.password' 


   e 

   'authData.email' 


   em vez 


   de 

   'authData.signupForm.email.value'... (eu já havia feito isso)...











   ------> ok........ -----> O QUE MAIS?










   --> AGORA DEVEMOS VOLTAR AO NOSSO APP E TESTAR FAZER LOGIN 




   com 




   um user nosso....












   --> ISSO DEVE FUNCIONAR.... 


















   -------> OK... 

   FEITO 


   ISSO TUDO,





   e logando com uma conta de 

   'exemplo@teste.com'



   e senha de '

   EXEMPLOEXEMPLO',





   CONSEGUIMOS 


   OBTER 






   VÁRIAS COISAS NA NOSSA LOCALSTORAGE....






   O QUE TEMOS NA NOSSA LOCALSTORAGE,

   AGORA, 

   É :






   'userID',



   'token' 




   e 



   'expiryDate',


   SINAL QUE 


   NOSSO CÓDIGO 




   BACK E FRONTEND FUNCIONOU....









   --------> UM CONSOLE.LOG LÁ DO FRONTEND NOS MOSTRA QUE 


   ESSE 



   LOGIN ATTEMPT FOI SUCCESSFUL:



   {token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6I…4NjB9.OXQE6lEubA4FitOrlo35Iy_aHQ-Hgmb8FnFKpW7QToQ', userId: '61b0329a5e008f6ae8046c8a'}token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6ImV4ZW1wbG9AdGVzdGUuY29tIiwidXNlcklkIjoiNjFiMDMyOWE1ZTAwOGY2YWU4MDQ2YzhhIiwiaWF0IjoxNjM4OTM3MjYwLCJleHAiOjE2Mzg5NDA4NjB9.OXQE6lEubA4FitOrlo35Iy_aHQ-Hgmb8FnFKpW7QToQ"userId: "61b0329a5e008f6ae8046c8a"[[Prototype]]: Object
01:21:00.279 Feed.js:53 1






-----------------------------










PROFESSOR FALA 




DO 


'LOCAL STORAGE'




no chrome devTools... --> VAMOS 

VER 

AQUELE 



'token',



O

'userId',



e a 

'expiryDate',




OU SEJA,


A DATA (inclusive a token)


QUE 

GERAMOS
 
 LÁ NO SERVER/BACKEND..










 ---------------------------------------












 OK....  JWT.IO ---------> LÁ PODEMOS APRENDER __ MAIS SOBRE__ JSON WEB TOKENS...








 --> E NESSE SITE DE 'JWT.IO',


 SE VOCÊ COPIAR 

 SUA 


 TOKEN 

 E COLAR 

 NAQUELE FIELD 



 NA HOME PAGE,


 VOCÊ PODE 


 VER VÁRIOS 

 DADOS,


 COMO 


 OS HEADERS,



 PAYLOAD,


 ETC ETC...  ----------> VOCÊ PODE VER VÁRIAS COISAS... ->  A ÚNICA COISA QUE 


 VOCÊ NÃO VERÁ,


 OBVIAMENTE,

 SERÁ 

 O 


 __SECREt__ VINCULADO_ a 
 ESSA TOKEN...











 --> MAS __ SE VOCÊ TIVER___ O SECRET__ DE VERDADE,


 o código 

 QUE 

 VOCÊ TEM 


 NO SEU SERVER,


 LÁ 




 NAQUELE SEGUNDO PARÂMETRO 

 DE 


 'jwt.sign()' (no controller de 'auth.js', no caso de nosso código),





 SE VOCÊ INSERIR ISSO AÍ 




 LÁ 




 NAQUELE FIELD DE 


 'VERIFY SIGNATURE',




 NAQUELE 

 ESPAÇO/SLOT 

 DE 

 'your-256-bit-secret',







 __ VOCÊ __ PODE 'VALIDATE' 

 ESSA 

 SUA 


 JSON WEB TOKEN... -----> 












 COMO SABEMOS 


 SE 

 ESSE SECRET É 'VÁLIDO'? ------> bem, 



 se você 





 COLAR ESSE SECRET AÍ _ E 



 ENTÃO SUA 


 __ TOKEN __ QUE VOCÊ COPIOU E COLOU DO LOCAL STORAGE 

 DO USER 




 NAQUELE 




 SLOT DE 'ENCODED' 


 ______NÃO MUDAR___, 

 é sinal 


 de que 



 ESSA TOKEN É TOTALMENTE VÁLIDA... (


   pq a token SÓ FICARÁ IGUAL, NESSA PAGE DE 'jwt.io',



   SE 



   VOCÊ INPUTTAR O SECRET DE VERDADE NAQUELE 

   ESPAÇO ALI..., espaço de 'your-256-bit-secret'....
 )










 lembre-se:





 JWT.IO












 EX,


 TESTE COM 

 ESSA TOKEN:


 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6ImV4ZW1wbG9AdGVzdGUuY29tIiwidXNlcklkIjoiNjFiMDMyOWE1ZTAwOGY2YWU4MDQ2YzhhIiwiaWF0IjoxNjM4OTM3MjYwLCJleHAiOjE2Mzg5NDA4NjB9.OXQE6lEubA4FitOrlo35Iy_aHQ-Hgmb8FnFKpW7QToQ






 e com 



 O NOSSO SECRET:


 'zVzS42wNmzOOmlRgYCNWE1dxTH4n_sL6JuDnNj2srF2B7YxRsAgVmvqO8z14Wd3nzOqXzseBAjJ7PA5RSzjs0GsdrR5nxrVu8NPQJjooJLq2GqEl4h9JxwJ8zg5d_Fl2l3Q3n8yf13Gydum25V3mYRUy--L1EskSMs2PcEXLOJM'


















 ---> DE FATO, ISSO FUNCIONOU... 


 BEM INTERESSANTE...




 





 ----------------> também vemos nossa payload data,




 tudo 



 certinho...  








 ------> PROFESSOR EXPLICA QUE __ TEORICAMENTE PODEMOS 


 'EXTRACT THAT DATA' ( A
 
 
 
 payload 
 
 data,
 
 
 
 que 
 
 no 
 
 caso 
 é 
 
 
 algo assim:
 
 
 
 {
  "email": "exemplo@teste.com",
  "userId": "61b0329a5e008f6ae8046c8a",
  "iat": 1638937260,
  "exp": 1638940860
}
 
 
 
 
 
 ),




 PODEMOS 



 EXTRAIR 

 ESSA 


 DATA 
 LÁ NO FRONTEND,


 PARA 


 ENTÃO USAR 

 NA NOSSA INTERFACE/APP, 








 mas que 
 isso aí pode 

 ser 


 PERIGOSO,

 E QUE 

 VOCÊ _ NÃO PODE/NÃO DEVE __ 




 INSERIR 'SENSITIVE INFORMATION' NESSE PAYLOAD QUE VOCÊ RETORNA AO USER 


 NESSA 
 JSON WEB TOKEN... ----------> MAS 


 ISSO 

 TBM 



 TE MOSTRA,

 ESSE 

 SITE 

 DE 

 'JWT.IO',


 que 



 SE NÓS 



 __TENTARMOS 


 EDITAr___ NOSSO 





 PAYLOAD POR CONTA PRÓPRIA,


 COMO POR EXEMPLO TENTAR_ _EDITAR __ O 'email address',






 O TOKEN 

 VAI MUDAR 



NO CAMPO DA ESQUERDA,



O QUE 

FARÁ 

COM QUE 

ESSA TOKEN '''NOVA''' (Com essa alteração maliciosa aí)



NÃO __ FIQUE 'VALIDATED',



pq ela terá mudado sua própria data, o que, consequentemente,


altera sua key (token value) em si.. -------> TUDO PQ 




'THE TOKEN WONT BE THE SAME AS IT WAS WHEN IT WAS GENERATED IN THE SERVER,


WITH THIS SPECIFIC SECRET....'''










--------> OK.... -----> ENTÃO, RESUMINDO:



1) TENTAMOS EDITAR A  'PAYLOAD' DATA DESSA TOKEN --> VALIDATE DESSA TOKEN VAI  __ FAIL __




2) TENTAMOS EDITAR O __SECRET__ associado a essa  token --> VALIDATE DESSA TOKEN __ TAMBÉM VAI FAIL..













-----> OK, NÃO PODEMOS 'MESS AROUND' COM A TOKEN NO CLIENT,

PQ 

O 



SERVER __ VAI _DETECTAR__ 

ESSAS SACANAGENS...












--> E É ASSIM QUE 

PODEMOS 

'LOGIN',




E COMO PODEMOS 'TRABALHAR COM TOKENS',


para 

__SABER__ EXATAMENTE __ QUANDO UM USER ESTÁ 

'LOGGED IN'...










------------> ENTRETANTO,




AINDA __ ESTAMOS __ COM UM __ PEDAÇO __ IMPORTANTE __ 

DE INFO FALTANDO... 






--> o que é isso?








--> BEM, EU CHUTO QUE SÃO 'GUARDS',


ou, em outras palavras,




A 'AUTHORIZATION' 

de nosso 

app (




  guard de routes,



  pedaços restritos de nosso app,
  que 

  só poderão ser utilizados por alguém que tenha uma dessas tokens...
)













--> NÃO, MAS ACHO QUE NÃO É ISSO.... -------> 






PROFESSOR EXPLICA QUE 

TEMOS A TOKEN,
 
 SIM ,









 __ MAS AGORA __ AINDA PRECISAMOS _ 'ATTACH THAT TOKEN TO REQUESTS',



 PRECISAMOS 


 FAZER COM QUE 


 ESSA TOKEN 


 FIQUE 

 ANEXADA


 A TODO E QUALQUER 


 REQUEST 

 QUE 

 SAI 


 DE 


 NOSSO 


 FRONTEND.... ---> E TAMBÉM PRECISAMOS CONFIGURAR NOSSO BACKEND,

 FAZER COM QUE 

 ELE PROCURE POR ESSA TOKEN 


 EM ALGUMAS DAS ROUTES,


 para que sejam criadas/estabelecidas 




 'GUARDS'...











 --------> VAMOS COLOCAR ESSE ANEXO DA TOKEN __ EM TODO E QUALQUER REQUEST__ 


 FEITO POR AQUELE USER... -> PORTANTO,


 __PROVAVELMENTE__ VAMOS USAR 



 'app.js' (arquivo central do nosso app nodeexpress)




 PARA 



 ANEXAR 


 ESSA TOKEN EM ALGUM MIDDLEWARE...













 -> O QUE MAIS TEMOS QUE FAZER?








 --> TEMOS QUE CONECTAR AQUELA FEATURE DE 'New Post'


 AO __ NOSSO USER (cada novo post deve ser 
 
 
 ATRIBUÍDO 
 
 
 
 AO USER QUE ESTÁ 'LOGGED IN'...
 
 
 
 
 
 
 ) 







 --> ALÉM DISSO,



 DEVEMOS ASSEGURAR QUE 


 'ONLY USERS THAT CREATED A POST CAN EDIT IT'...






 (

   o resto dos users pode VER SEU POST,

   mas nõa pode o editar...


 )







 -------------------------------










 OK, VAMOS VER ISSO NA PRÓXIMA AULA...





 